#!/usr/bin/env bash
set -euo pipefail

VERSION="1.0.7"

usage() {
  cat <<'EOF'
cyberpanel-dotnet v1.0.7

Usage:
  cyberpanel-dotnet enable <domain> --dll <MainDll>
  cyberpanel-dotnet deploy <domain> [--from <dir>]
  cyberpanel-dotnet toggle <domain> php|dotnet
  cyberpanel-dotnet disable <domain> [--purge]
  cyberpanel-dotnet signalr <domain> on|off
  cyberpanel-dotnet --help | -h
  cyberpanel-dotnet --version

Notes:
- App path: /home/<domain>/public_html/NetCoreApp
- Auto-port stored in: /home/<domain>/public_html/NetCoreApp/.dotnet-port
- SignalR/WebSockets is OFF by default. Enable per site:
    sudo cyberpanel-dotnet signalr <domain> on
- When SignalR is ON, we:
    * forward Upgrade/Connection + X-Forwarded-* headers
    * add an explicit OpenLiteSpeed websocket context for /ConnectionHub
EOF
}

err(){ echo "[X] $*" >&2; exit 1; }
info(){ echo "[i] $*"; }
ok(){ echo "[âœ“] $*"; }

require_root(){ [[ $EUID -eq 0 ]] || err "Run as root (sudo)."; }
need_bin(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1"; }

find_vhost(){
  local domain="$1"
  local base="/usr/local/lsws/conf/vhosts/${domain}"
  local a="${base}/vhost.conf"
  local b="${base}/vhconf.conf"
  [[ -f "$a" ]] && { echo "$a"; return; }
  [[ -f "$b" ]] && { echo "$b"; return; }
  err "vhost not found for ${domain}. Create the website first in CyberPanel."
}

backup_vhost(){ cp -a "$1" "$1.bak.$(date +%s)"; }

pick_port(){
  local appdir="$1"
  local pf="${appdir}/.dotnet-port"
  if [[ -f "$pf" ]]; then cat "$pf"; return; fi
  need_bin ss || true
  local p
  for p in $(shuf -i 50000-50999 -n 200); do
    if ! ss -ltn 2>/dev/null | grep -q ":$p " ; then
      echo "$p" > "$pf"; echo "$p"; return
    fi
  done
  err "Failed to pick a free port"
}

ensure_includes(){ local d="/usr/local/lsws/conf/vhosts/$1/includes"; mkdir -p "$d"; echo "$d"; }
ensure_line_in_file(){ local line="$1" file="$2"; grep -qF "$line" "$file" || echo "$line" >> "$file"; }
set_autoindex_off(){ local v="$1"; grep -qE '^\s*autoIndex\s+' "$v" || echo "autoIndex 0" >> "$v"; }

# ---------------- Permissions helpers ----------------

ensure_parent_perms(){
  local domain="$1"
  chmod 755 "/home/${domain}" 2>/dev/null || true
  chmod 755 "/home/${domain}/public_html" 2>/dev/null || true
}

ensure_perms(){
  local app="$1"
  find "$app" -type d -exec chmod 755 {} \; 2>/dev/null || true
  find "$app" -type f -exec chmod 644 {} \; 2>/dev/null || true
  mkdir -p "$app/wwwroot/uploads"
  chown -R www-data:www-data "$app/wwwroot/uploads" 2>/dev/null || true
  chmod -R 770 "$app/wwwroot/uploads" 2>/dev/null || true
}

# --------------- Include writers (canonical templates) ---------------
# When WS=on we:
#   - add header forwarding (Upgrade/Connection + X-Forwarded-*)
#   - add explicit websocket context /ConnectionHub -> 127.0.0.1:<port>

_write_dotnet_conf_file(){
  # $1=dest_file  $2=port  $3=ws_flag ("on"|"off")
  local dest="$1" ; local port="$2" ; local ws="$3"

  local ws_headers=""
  local ws_ctx=""
  if [[ "$ws" == "on" ]]; then
    ws_headers=$'  requestHeader set "Upgrade" "%{ENV:HTTP_UPGRADE}"\n'\
$'  requestHeader set "Connection" "%{ENV:HTTP_CONNECTION}"\n'\
$'  requestHeader set "X-Forwarded-Proto" "https"\n'\
$'  requestHeader set "X-Forwarded-Host"  "%{HTTP_HOST}"\n'\
$'  requestHeader set "X-Forwarded-For"   "%{CLIENTIP}"'

    ws_ctx=$(cat <<EOFCTX
# WebSocket hub context (explicit mapping for /ConnectionHub)
context /ConnectionHub {
  type                    websocket
  address                 127.0.0.1:${port}
}
EOFCTX
)
  fi

  cat >"$dest" <<EOF
extprocessor dotnet_backend {
  type                    proxy
  address                 127.0.0.1:${port}
  maxConns                200
  initTimeout             60
  retryTimeout            0
  respBuffer              0
}

${ws_ctx}
context / {
  type                    proxy
  handler                 dotnet_backend

  enableRewrite           1
  rewriteCond             %{HTTP:Upgrade} =websocket
  rewriteRule             .* - [E=HTTP_UPGRADE:%{HTTP:Upgrade},E=HTTP_CONNECTION:%{HTTP:Connection}]

${ws_headers}
  rewrite  {
    rewriteCond %{REQUEST_URI} \.(dll|exe|pdb|deps\.json|runtimeconfig\.json|ps1|cmd|sh)$
    rewriteRule .* - [F,L]
    rewriteCond %{REQUEST_URI} (appsettings\.json|appsettings\..*\.json|\.env|\.ini|\.config)$
    rewriteRule .* - [F,L]
    rewriteCond %{REQUEST_URI} \.(sqlite|db|bak|zip|tar\.gz)$
    rewriteRule .* - [F,L]
  }
}
EOF
}

write_dotnet_conf_off(){ _write_dotnet_conf_file "$1/dotnet-mode.conf" "$2" "off"; }
write_dotnet_conf_on(){  _write_dotnet_conf_file "$1/dotnet-mode.conf" "$2" "on";  }

write_php_conf(){
  local dir="$1"
  cat >"${dir}/php-mode.conf" <<'EOF'
index  {
  useServer              0
  indexFiles             index.php, index.html, index.htm
}
rewrite  {
  rewriteCond %{REQUEST_URI} ^/NetCoreApp($|/.*)
  rewriteRule .* - [F,L]
}
EOF
}

link_mode(){
  local dir="$1" target="$2"
  ln -sfn "${dir}/${target}" "${dir}/app-mode.conf"
  chown lsadm:lsadm "${dir}/app-mode.conf" 2>/dev/null || true
}

restart_ols(){ systemctl restart lsws; }
status_service(){ systemctl --no-pager --lines=20 status "dotnet-$1" || true; }

# ---------------- Commands ----------------

enable_cmd(){
  require_root
  need_bin dotnet
  local domain="$1"; shift || true
  local dll=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dll) dll="${2:-}"; shift 2;;
      *) err "Unknown arg: $1";;
    esac
  done
  [[ -n "$domain" ]] || err "domain required"
  [[ -n "$dll" ]] || err "--dll <MainDll> is required"

  local pub="/home/${domain}/public_html"
  local app="${pub}/NetCoreApp"
  mkdir -p "${app}/wwwroot/uploads"

  local vhost; vhost="$(find_vhost "$domain")"
  backup_vhost "$vhost"

  local port; port="$(pick_port "$app")"
  info "Using port ${port}"

  ensure_parent_perms "$domain"
  ensure_perms "$app"

  cat >"/etc/systemd/system/dotnet-${domain}.service" <<EOF
[Unit]
Description=.NET app for ${domain} (public_html/NetCoreApp)
After=network.target

[Service]
WorkingDirectory=${app}
ExecStart=/usr/bin/dotnet ${app}/${dll} --urls http://127.0.0.1:${port}
Restart=always
RestartSec=2
User=www-data
Group=www-data
Environment=ASPNETCORE_URLS=http://127.0.0.1:${port}
Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "dotnet-${domain}.service" >/dev/null || true
  systemctl restart "dotnet-${domain}.service"

  local inc; inc="$(ensure_includes "$domain")"
  write_dotnet_conf_off "$inc" "$port"      # default: WS OFF
  write_php_conf "$inc"
  set_autoindex_off "$vhost"
  ensure_line_in_file "# cyberpanel-dotnet include (do not remove)" "$vhost"
  ensure_line_in_file "include ${inc}/app-mode.conf" "$vhost"
  link_mode "$inc" "dotnet-mode.conf"

  restart_ols
  ok "Enabled .NET for ${domain} (port ${port}). App dir: ${app}"
  status_service "$domain"
}

deploy_cmd(){
  require_root
  local domain="${1:-}"; shift || true
  local from=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --from) from="$2"; shift 2;;
      *) err "Unknown arg: $1";;
    esac
  done
  [[ -n "$domain" ]] || err "domain required"
  local app="/home/${domain}/public_html/NetCoreApp"
  [[ -d "$app" ]] || err "App dir not found: $app"
  if [[ -n "$from" ]]; then
    [[ -d "$from" ]] || err "Source dir not found: $from"
    info "Deploying from $from to $app (keeping uploads)"
    rsync -a --delete --exclude 'wwwroot/uploads/' "$from"/ "$app"/
  fi

  ensure_parent_perms "$domain"
  ensure_perms "$app"

  systemctl restart "dotnet-${domain}.service"
  ok "Deployed and restarted dotnet-${domain}"
}

toggle_cmd(){
  require_root
  local domain="${1:-}"; local mode="${2:-}"
  [[ -n "$domain" && -n "$mode" ]] || err "Usage: toggle <domain> php|dotnet"
  local inc="/usr/local/lsws/conf/vhosts/${domain}/includes"
  [[ -d "$inc" ]] || err "Includes dir not found: $inc"
  case "$mode" in
    php) link_mode "$inc" "php-mode.conf"; restart_ols; ok "Switched ${domain} to PHP mode";;
    dotnet) link_mode "$inc" "dotnet-mode.conf"; restart_ols; systemctl restart "dotnet-${domain}.service"; ok "Switched ${domain} to .NET mode";;
    *) err "Unknown mode: $mode";;
  esac
}

disable_cmd(){
  require_root
  local domain="${1:-}"; shift || true
  local purge="no"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --purge) purge="yes"; shift;;
      *) err "Unknown arg: $1";;
    esac
  done
  local inc="/usr/local/lsws/conf/vhosts/${domain}/includes"
  if [[ -d "$inc" ]]; then
    link_mode "$inc" "php-mode.conf" || true
    restart_ols || true
  fi
  systemctl stop "dotnet-${domain}.service" 2>/dev/null || true
  systemctl disable "dotnet-${domain}.service" 2>/dev/null || true
  rm -f "/etc/systemd/system/dotnet-${domain}.service"
  systemctl daemon-reload || true
  if [[ "$purge" == "yes" ]]; then rm -rf "/home/${domain}/public_html/NetCoreApp"; fi
  ok "Disabled .NET for ${domain} (purge=${purge})"
}

# --------------- SignalR/WebSocket toggle (safe & idempotent) ---------------

_get_port_from_include(){
  # extract digits AFTER the colon in: address 127.0.0.1:<port>
  sed -n 's/.*address[[:space:]]\+127\.0\.0\.1:\([0-9][0-9]*\).*/\1/p' "$1" | head -n1
}

_get_port_from_app(){
  local domain="$1"
  local pf="/home/${domain}/public_html/NetCoreApp/.dotnet-port"
  [[ -f "$pf" ]] && awk '{print $1}' "$pf" | grep -E '^[0-9]+$' || echo ""
}

signalr_cmd(){
  require_root
  local domain="${1:-}"; local state="${2:-}"
  [[ -n "$domain" && -n "$state" ]] || err "Usage: signalr <domain> on|off"

  local inc_dir="/usr/local/lsws/conf/vhosts/${domain}/includes"
  local conf="${inc_dir}/dotnet-mode.conf"
  [[ -f "$conf" ]] || err "dotnet-mode.conf not found for ${domain} (run 'enable' first)."

  # get port safely
  local port
  port="$(_get_port_from_include "$conf")"
  [[ -z "$port" ]] && port="$(_get_port_from_app "$domain")"
  [[ -n "$port" ]] || err "Unable to determine backend port for ${domain}."

  # backup current include
  local backup="${conf}.bak.$(date +%s)"
  cp -a "$conf" "$backup"

  # write a temp new file from the canonical template
  local tmp="${conf}.tmp.$$"
  case "$state" in
    on)  _write_dotnet_conf_file "$tmp" "$port" "on"  ;;
    off) _write_dotnet_conf_file "$tmp" "$port" "off" ;;
    *)   err "Unknown state: $state (use on|off)";;
  esac

  # atomic replace
  mv -f "$tmp" "$conf"

  # restart OLS; if it fails, roll back
  if ! systemctl restart lsws; then
    echo "[X] OpenLiteSpeed restart failed. Restoring previous config..." >&2
    mv -f "$backup" "$conf" 2>/dev/null || true
    systemctl restart lsws || true
    exit 1
  fi

  ok "SignalR/WebSocket headers ${state} for ${domain} (port ${port})"
}

# ---------------- Main ----------------

main(){
  [[ $# -lt 1 ]] && { usage; exit 1; }
  case "$1" in
    --help|-h) usage;;
    --version) echo "$VERSION";;
    enable)  shift; [[ $# -ge 1 ]] || err "enable <domain> --dll <MainDll>"; enable_cmd "$@";;
    deploy)  shift; [[ $# -ge 1 ]] || err "deploy <domain> [--from <dir>]"; deploy_cmd "$@";;
    toggle)  shift; [[ $# -ge 2 ]] || err "toggle <domain> php|dotnet"; toggle_cmd "$@";;
    disable) shift; [[ $# -ge 1 ]] || err "disable <domain> [--purge]"; disable_cmd "$@";;
    signalr) shift; [[ $# -ge 2 ]] || err "signalr <domain> on|off"; signalr_cmd "$@";;
    *) usage; err "Unknown command: $1";;
  esac
}
main "$@"
