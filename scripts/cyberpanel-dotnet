#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s extglob nullglob

# ===================== UI helpers =====================
red(){ echo -e "\e[31m$*\e[0m"; }
grn(){ echo -e "\e[32m$*\e[0m"; }
yel(){ echo -e "\e[33m$*\e[0m"; }
err(){ red "[ERROR] $*" 1>&2; exit 1; }
info(){ echo "[i] $*"; }
sudo_ok(){ [[ ${EUID:-$(id -u)} -eq 0 ]] || err "Run as root (sudo)."; }
need(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1 (please install it)"; }

# ===================== Globals =====================
SYSTEMD_DIR="/etc/systemd/system"
ENV_DIR="/etc/dotnet-apps"
STATE_DIR="/etc/cyberpanel-dotnet"
PORT_RANGE_START=${PORT_RANGE_START:-5100}
PORT_RANGE_END=${PORT_RANGE_END:-8999}
MARK_BEGIN="# >>> cyberpanel-dotnet BEGIN"
MARK_END="# <<< cyberpanel-dotnet END"
MARK_EXT_BEGIN="# >>> cyberpanel-dotnet EXTAPP BEGIN"
MARK_EXT_END="# <<< cyberpanel-dotnet EXTAPP END"

LSWS_ROOT=""
CONF_DIR=""
HTTPD_CONF=""
VHOSTS_DIR=""

mkdir -p "$STATE_DIR" "$ENV_DIR"

# ===================== ID helpers =====================
sanitize_id(){
  echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g; s/[.]/_/g'
}
service_name(){ local id; id=$(sanitize_id "$1"); echo "dotnet-app@${id}.service"; }
service_path(){ echo "$SYSTEMD_DIR/$(service_name "$1")"; }
envfile_path(){ local id; id=$(sanitize_id "$1"); echo "$ENV_DIR/${id}.env"; }

# ===================== OLS discovery =====================
_detect_lsws_root(){
  if [[ -n "${LSWS_ROOT:-}" && -x "${LSWS_ROOT}/bin/lswsctrl" ]]; then echo "$LSWS_ROOT"; return; fi
  if [[ -x "/usr/local/lsws/bin/lswsctrl" ]]; then echo "/usr/local/lsws"; return; fi
  if command -v lswsctrl >/dev/null 2>&1; then
    local p; p=$(command -v lswsctrl); p=$(readlink -f "$p" 2>/dev/null || echo "$p")
    echo "${p%/bin/lswsctrl}"; return
  fi
  [[ -d "/usr/local/lsws" ]] && { echo "/usr/local/lsws"; return; }
  return 1
}

ols_paths(){
  LSWS_ROOT="$(_detect_lsws_root)" || err "OpenLiteSpeed not found"
  CONF_DIR="$LSWS_ROOT/conf"
  HTTPD_CONF="$CONF_DIR/httpd_config.conf"
  VHOSTS_DIR="$CONF_DIR/vhosts"
  [[ -f "$HTTPD_CONF" && -d "$VHOSTS_DIR" ]] || err "OLS conf missing under $CONF_DIR"
}

ols_reload(){
  if [[ -x "$LSWS_ROOT/bin/lswsctrl" ]]; then
    "$LSWS_ROOT/bin/lswsctrl" reload || true
  fi
  systemctl reload lsws 2>/dev/null || systemctl restart lsws 2>/dev/null || true
}

trim_slash(){ local p="${1:-}"; p="${p%/}"; echo "$p"; }

# ===================== vhconf/vhost.conf helpers =====================
_expand_vars(){
  local raw="${1:-}" vhconf="${2:-}"
  local vhroot="" vhname="" serverroot="$LSWS_ROOT"
  vhname="$(basename "$(dirname "$vhconf")")"
  vhroot="$(awk '/^[ \t]*vhRoot[ \t]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  vhroot="${vhroot%\"}"; vhroot="${vhroot#\"}"
  raw="${raw//\$VH_ROOT/$vhroot}"
  raw="${raw//\$SERVER_ROOT/$serverroot}"
  raw="${raw//\$VH_NAME/$vhname}"
  echo "$raw"
}

docroot_from_vhconf(){
  local vhconf="$1"
  local dr
  dr="$(awk '/^[ \t]*docRoot[ \t]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  dr="${dr%\"}"; dr="${dr#\"}"
  [[ -z "$dr" ]] && return 1
  dr="$(_expand_vars "$dr" "$vhconf")"
  dr="${dr%\"}"; dr="${dr#\"}"
  dr="$(trim_slash "$dr")"
  [[ -n "$dr" ]] && echo "$dr" && return 0
  return 1
}

# Resolve vhost name from listener map lines in httpd_config.conf
_vhname_from_map(){
  local domain="$1"
  awk -v D="$domain" '
    BEGIN{IGNORECASE=1; in=0}
    /^[ \t]*listener[ \t]+/ {in=1; next}
    in==1 && /^[ \t]*map[ \t]+/ { if (index(tolower($0), tolower(D))) { print $2; exit } }
    in==1 && /^[ \t]*}/ {in=0}
  ' "$HTTPD_CONF" 2>/dev/null || true
}

# Expand configFile path for a virtualHost block
_configfile_for_vh(){
  local vhname="$1"
  local raw
  raw="$(awk -v N="$vhname" '
    BEGIN{IGNORECASE=1; in=0}
    /^[ \t]*virtualHost[ \t]+/ { in = ($2==N); next }
    in==1 && /^[ \t]*configFile[ \t]+/ { print $2; exit }
    in==1 && /^[ \t]*}/ { in=0 }
  ' "$HTTPD_CONF" 2>/dev/null || true)"
  [[ -z "$raw" ]] && return 1
  local exp="${raw//\$SERVER_ROOT/$LSWS_ROOT}"
  exp="${exp//\$VH_NAME/$vhname}"
  if [[ "${exp:0:1}" != "/" ]]; then exp="$LSWS_ROOT/$exp"; fi
  echo "$exp"
}

# Return the ACTUAL vhost config file used by OLS (vhost.conf OR vhconf.conf)
vhconf_for(){
  local domain="$1" override="${2:-}"
  [[ -n "$override" && -f "$override" ]] && { echo "$override"; return; }

  local vhname conf
  vhname="$(_vhname_from_map "$domain")"
  if [[ -n "$vhname" ]]; then
    conf="$(_configfile_for_vh "$vhname" || true)"
    [[ -n "$conf" && -f "$conf" ]] && { echo "$conf"; return; }
    # fallback to standard locations
    [[ -f "$VHOSTS_DIR/$vhname/vhost.conf" ]] && { echo "$VHOSTS_DIR/$vhname/vhost.conf"; return; }
    [[ -f "$VHOSTS_DIR/$vhname/vhconf.conf" ]] && { echo "$VHOSTS_DIR/$vhname/vhconf.conf"; return; }
  fi

  # try path by domain
  [[ -f "$VHOSTS_DIR/$domain/vhost.conf" ]] && { echo "$VHOSTS_DIR/$domain/vhost.conf"; return; }
  [[ -f "$VHOSTS_DIR/$domain/vhconf.conf" ]] && { echo "$VHOSTS_DIR/$domain/vhconf.conf"; return; }

  # final brute force
  local f
  for f in "$VHOSTS_DIR"/*/vhost.conf "$VHOSTS_DIR"/*/vhconf.conf; do
    [[ -f "$f" ]] || continue
    if dr="$(docroot_from_vhconf "$f" || true)"; then
      [[ "$(trim_slash "$dr")" == "/home/$domain/public_html" ]] && { echo "$f"; return; }
      echo "$dr" | grep -qiE "/$domain(/|.*)public_html/?$" && { echo "$f"; return; }
    fi
  done

  err "OpenLiteSpeed vhost for '$domain' not found under $VHOSTS_DIR.
Hints:
  • Ensure the site exists in CyberPanel.
  • Or pass an explicit file path:  --vhconf /usr/local/lsws/conf/vhosts/<name>/(vhost|vhconf).conf"
}

workdir_for_domain(){
  local domain="$1"; local vh=""
  vh="$(vhconf_for "$domain" "${2:-}")" || exit 1
  if dr="$(docroot_from_vhconf "$vh")"; then echo "$dr"; return; fi
  [[ -d "/home/$domain/public_html" ]] && { echo "/home/$domain/public_html"; return; }
  local guess=""
  guess="$(find /home -maxdepth 3 -type d -path "/home/*/public_html" -print 2>/dev/null | grep "/$domain/" -m1 || true)"
  [[ -n "$guess" ]] || err "Could not find document root for '$domain'. Ensure the website exists and try again."
  echo "$guess"
}

# ===================== dotnet + port helpers =====================
find_dotnet(){ command -v dotnet >/dev/null 2>&1 && command -v dotnet || return 1; }

port_in_use(){ ss -ltnH | awk '{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$1"; }

alloc_port(){
  local domain="$1"
  local seed=$(( ( $(echo -n "$domain" | md5sum | cut -c1-6 | tr 'a-f' '1-6') % 1000 ) + PORT_RANGE_START ))
  local p
  for ((p=seed; p<=PORT_RANGE_END; p++)); do
    if ! port_in_use "$p"; then echo "$p"; return; fi
  done
  err "No free port in $PORT_RANGE_START..$PORT_RANGE_END"
}

get_port_from_service(){
  local domain="$1" envf svc_path p
  envf="$(envfile_path "$domain")"
  if [[ -f "$envf" ]]; then
    p="$(awk -F= '/^PORT=/{print $2; exit}' "$envf" | tr -d ' \t\r')"
    [[ -n "$p" ]] && { echo "$p"; return; }
  fi
  svc_path="$(service_path "$domain")"
  if [[ -f "$svc_path" ]]; then
    p="$(sed -n 's/^Environment=PORT=\([0-9]\+\).*$/\1/p' "$svc_path" | tail -n1)"
    [[ -n "$p" ]] && { echo "$p"; return; }
    p="$(sed -n 's/^Environment=ASPNETCORE_URLS=.*:\([0-9]\+\).*$/\1/p' "$svc_path" | tail -n1)"
    [[ -n "$p" ]] && { echo "$p"; return; }
  fi
  p="$(systemctl show "$(service_name "$domain")" -p Environment 2>/dev/null | sed -n 's/^Environment=.*PORT=\([0-9]\+\).*$/\1/p' | head -n1)"
  [[ -n "$p" ]] && echo "$p" || return 1
}

resolve_dll_from_marker(){
  local workdir="$1"
  if [[ -f "$workdir/.dotnet" ]]; then
    local dll
    dll="$(awk -F= '/^\s*DLL\s*=/{print $2; exit}' "$workdir/.dotnet" | tr -d ' \t\r')"
    [[ -n "$dll" ]] && { echo "$dll"; return; }
  fi
  return 1
}

resolve_dll(){
  local workdir="$1"; local dll="${2:-}"
  if [[ -z "$dll" ]]; then
    if dll="$(resolve_dll_from_marker "$workdir")"; then :; else err "--dll is required (or put DLL=YourApp.dll in $workdir/.dotnet)"; fi
  fi
  if [[ "$dll" = /* && -f "$dll" ]]; then echo "$dll"; return; fi
  if [[ -f "$workdir/$dll" ]]; then echo "$workdir/$dll"; return; fi
  if [[ -d "$workdir" ]]; then
    local found; found="$(find "$workdir" -maxdepth 2 -type f -name "$(basename "$dll")" -print -quit || true)"
    [[ -n "$found" ]] && { echo "$found"; return; }
  fi
  err "DLL '$dll' not found under '$workdir'. Upload your published files."
}

# ===================== OLS editing (robust) =====================

# Remove ALL existing root "context / { ... }" blocks (brace-balanced)
remove_root_contexts(){
  local vhconf="$1"
  awk '
    BEGIN{depth=0; inroot=0}
    /^[ \t]*context[ \t]*\/[ \t]*\{/ { inroot=1; depth=1; next }
    inroot==1 {
      for(i=1;i<=length($0);i++){
        c=substr($0,i,1)
        if(c=="{")depth++
        else if(c=="}"){ depth--; if(depth==0){ inroot=0; next } }
      }
      next
    }
    { print }
  ' "$vhconf" > "$vhconf.__no_root__"
  mv "$vhconf.__no_root__" "$vhconf"
}

# Drop any extprocessor with a given name (brace-balanced)
drop_extprocessor(){
  local vhconf="$1" name="$2"
  awk -v NAME="$name" '
    BEGIN{drop=0; depth=0}
    /^[ \t]*extprocessor[ \t]+/ && $2==NAME {
      drop=1; depth=0
      for(i=1;i<=length($0);i++){ c=substr($0,i,1); if(c=="{")depth++; else if(c=="}")depth--; }
      next
    }
    drop==1 {
      for(i=1;i<=length($0);i++){
        c=substr($0,i,1)
        if(c=="{") depth++
        else if(c=="}"){ depth--; if(depth<=0){ drop=0; break } }
      }
      if(drop==1) next
    }
    { print }
  ' "$vhconf" > "$vhconf.__no_ext__"
  mv "$vhconf.__no_ext__" "$vhconf"
}

ensure_vhDomain(){
  local vhconf="$1" domain="$2"
  if grep -qiE '^[[:space:]]*vhDomain[[:space:]]+' "$vhconf"; then
    local cur rest merged
    cur="$(grep -iE '^[[:space:]]*vhDomain[[:space:]]+' "$vhconf" | head -n1)"
    rest="${cur#*vhDomain}"; rest="$(echo "$rest" | tr -d '\r' | tr ',' ' ' | tr '[:upper:]' '[:lower:]')"
    merged="$(printf '%s\n%s\nwww.%s\n' "$rest" "$domain" "$domain" | tr ' ' '\n' | sed '/^$/d' | sort -u | paste -sd',' -)"
    awk -v NEW="vhDomain $merged" '
      BEGIN{done=0}
      { if (!done && $0 ~ /^[[:space:]]*vhDomain[[:space:]]+/) { print NEW; done=1 } else print $0 }
    ' "$vhconf" > "$vhconf.__vhd__" && mv "$vhconf.__vhd__" "$vhconf"
  else
    printf '\n# added by cyberpanel-dotnet\nvhDomain %s, %s\n' "$domain" "www.$domain" >> "$vhconf"
  fi
}

ensure_extproxy_and_root(){
  local vhconf="$1" vhname="$2" port="$3"
  local ep="cpdotnet-$(echo "$vhname" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g')"

  # clean old blocks
  drop_extprocessor "$vhconf" "$ep"
  remove_root_contexts "$vhconf"
  # drop our old markers if any
  sed -i '/^# >>> cyberpanel-dotnet BEGIN/,/^# <<< cyberpanel-dotnet END/d' "$vhconf" || true
  sed -i '/^# >>> cyberpanel-dotnet EXTAPP BEGIN/,/^# <<< cyberpanel-dotnet EXTAPP END/d' "$vhconf" || true

  # append extprocessor + ACME + root proxy
  cat >>"$vhconf" <<EOF
$MARK_EXT_BEGIN
extprocessor $ep {
  type                    proxy
  address                 127.0.0.1:$port
  maxConns                200
  pcKeepAliveTimeout      60
  initTimeout             60
  retryTimeout            0
  respBuffer              0
}
# Keep ACME static for SSL renewals
context /.well-known/acme-challenge/ {
  location                \$DOC_ROOT/.well-known/acme-challenge/
  allowBrowse             1
}
$MARK_EXT_END

$MARK_BEGIN
context / {
  type                    proxy
  proxyExtAppName         $ep
  addDefaultCharset       off
  cacheEnable             0
  rewrite                 0
}
$MARK_END
EOF
}

# Ensure listener maps for domain in httpd_config.conf (dedup, one per listener)
fix_listener_mappings(){
  local domain="$1" vhname="$2"
  local httpd="$HTTPD_CONF"
  [[ -f "$httpd" ]] || err "httpd_config.conf not found"

  cp -a "$httpd" "$httpd.bak.$(date +%s)"

  awk -v VH="$vhname" -v D1="$domain" -v D2="www.$domain" '
    BEGIN { blk=0; addr=""; sec="0" }
    {
      line=$0
      if (line ~ /^[ \t]*listener[ \t]+/) { blk=1; addr=""; sec="0"; print line; next }
      if (blk==1 && line ~ /^[ \t]*address[ \t]+/) { print line; next }
      if (blk==1 && line ~ /^[ \t]*secure[ \t]+/)  { print line; next }
      if (blk==1 && line ~ /^[ \t]*map[ \t]+/) {
        # drop any existing map lines for our domain(s)
        low = tolower(line)
        if (index(low, tolower(D1))>0 || index(low, tolower(D2))>0) { next }
        print line; next
      }
      if (blk==1 && line ~ /^[ \t]*}/) {
        # Always add a canonical map for this listener
        print "  map  " VH "  " D1 " " D2
        blk=0; print line; next
      }
      print line
    }
  ' "$httpd" > "$httpd.__new__"

  mv "$httpd.__new__" "$httpd"
  ols_reload

  echo "--- Listener mappings for $domain ---"
  awk -v D="$domain" '
    BEGIN{L="";A="";S="0"}
    /^[ \t]*listener[ \t]+/ {L=$2;A="";S="0"}
    /^[ \t]*address[ \t]+/  {print; next}
    /^[ \t]*secure[ \t]+/   {print; next}
    /^[ \t]*map[ \t]+/      { if (index(tolower($0),tolower(D))) print }
    /^[ \t]*}/              {print}
  ' "$httpd" | sed 's/^/  /'
}

# ===================== Commands =====================

cmd_check(){
  sudo_ok; ols_paths
  local domain="$1"; local vhconf=""
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  local docroot=""; docroot="$(docroot_from_vhconf "$vhconf" || true)"
  [[ -z "$docroot" ]] && docroot="/home/$domain/public_html"

  echo "LSWS_ROOT=$LSWS_ROOT"
  echo "CONF_DIR=$CONF_DIR"
  echo "VHOSTS_DIR=$VHOSTS_DIR"
  echo "HTTPD_CONF=$HTTPD_CONF"
  echo "VHCONF=$vhconf"
  echo "DOCROOT=$docroot"
  local p="$(get_port_from_service "$domain" || true)"
  echo "PORT=${p:-'(not assigned yet)'}"
}

cmd_port(){ sudo_ok; ols_paths; get_port_from_service "$1"; }

cmd_logs(){
  sudo_ok
  local domain="$1"; shift || true
  local lines=200 follow=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --lines|-n) lines="$2"; shift 2;;
      -f|--follow) follow=1; shift;;
      *) break;;
    esac
  done
  local unit="$(service_name "$domain")"
  if [[ "$follow" -eq 1 ]]; then
    journalctl -u "$unit" -f
  else
    journalctl -u "$unit" -n "${lines}"
  fi
}

cmd_redeploy(){
  sudo_ok
  if [[ $# -eq 0 ]]; then
    systemctl list-units 'dotnet-app@*.service' --no-legend | awk '{print $1}' | while read -r u; do systemctl restart "$u" || true; done
    echo "Redeployed all"
  else
    local domain="$1"
    systemctl restart "$(service_name "$domain")"
    echo "Redeployed $domain"
  fi
}

cmd_disable(){
  sudo_ok; ols_paths
  local domain="$1"
  systemctl stop "$(service_name "$domain")" || true
  systemctl disable "$(service_name "$domain")" || true

  local vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  # remove our blocks and any root context we added
  sed -i '/^# >>> cyberpanel-dotnet BEGIN/,/^# <<< cyberpanel-dotnet END/d' "$vhconf" || true
  sed -i '/^# >>> cyberpanel-dotnet EXTAPP BEGIN/,/^# <<< cyberpanel-dotnet EXTAPP END/d' "$vhconf" || true
  remove_root_contexts "$vhconf" || true
  ols_reload
  echo "Disabled $domain"
}

cmd_enable(){
  sudo_ok; ols_paths
  need awk; need sed; need grep
  local domain="" dll="" port="" vhconf="" docroot="" user="" uid=""
  local override_vh=""

  # args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dll) dll="$2"; shift 2;;
      --port) port="$2"; shift 2;;
      --vhconf) override_vh="$2"; shift 2;;
      --help|-h) echo "Usage: cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N] [--vhconf /path/to/vhost.conf]"; return 0;;
      *) domain="$1"; shift;;
    esac
  done
  [[ -n "$domain" ]] || err "Usage: enable <domain> --dll YourApp.dll"

  vhconf="$(vhconf_for "$domain" "$override_vh")"
  docroot="$(workdir_for_domain "$domain" "$vhconf")"
  dll="$(resolve_dll "$docroot" "$dll")"

  # infer user/uid from docroot owner
  uid="$(stat -c '%u' "$docroot" 2>/dev/null || echo 0)"
  user="$(getent passwd "$uid" | cut -d: -f1 || true)"
  [[ -n "$user" ]] || user="www-data"

  # port
  if [[ -z "${port:-}" ]]; then
    port="$(get_port_from_service "$domain" || true)"
    [[ -z "$port" ]] && port="$(alloc_port "$domain")"
  fi

  # write env
  local envf; envf="$(envfile_path "$domain")"
  cat >"$envf" <<EOF
DOMAIN=$domain
DOCROOT=$docroot
PORT=$port
USER=$user
DLL_PATH=$dll
EOF
  chmod 0644 "$envf"

  # ensure service template exists (should be installed by install.sh)
  local unit="$(service_name "$domain")"
  systemctl daemon-reload || true
  systemctl enable "$unit" >/dev/null 2>&1 || true
  systemctl restart "$unit"

  # vhost name for blocks
  local vhname="$(basename "$(dirname "$vhconf")")"

  # ensure vhDomain + proxy blocks + mappings
  ensure_vhDomain "$vhconf" "$domain"
  ensure_extproxy_and_root "$vhconf" "$vhname" "$port"
  fix_listener_mappings "$domain" "$vhname"
  ols_reload

  # print summary
  local id="$(sanitize_id "$domain")"
  grn "✅ Enabled $domain"
  echo "------------------------------------------------------------"
  echo "Public URL:    http(s)://$domain"
  echo "Reverse proxy: ADDED in $vhconf (OpenLiteSpeed) [cyberpanel-dotnet markers]"
  echo "Internal URL:  http://127.0.0.1:$port  (Kestrel)"
  echo "Systemd unit:  $(service_name "$domain")"
  echo "Env file:      $(envfile_path "$domain")"
  echo
  echo "Next steps:"
  echo " • Open your site:   https://$domain   (if SSL is configured in CyberPanel)"
  echo " • Live logs:        journalctl -u $(service_name "$domain") -f"
  echo " • Redeploy now:     sudo cyberpanel-dotnet redeploy $domain"
  echo " • Check detected:   sudo cyberpanel-dotnet check $domain"
  echo "------------------------------------------------------------"
}

cmd_fixmap(){
  sudo_ok; ols_paths
  local domain="$1"
  local vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  local vhname="$(basename "$(dirname "$vhconf")")"
  fix_listener_mappings "$domain" "$vhname"
}

# ===================== CLI =====================
usage(){
  cat <<EOF
cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel

Usage:
  cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N] [--vhconf /path/to/(vhost|vhconf).conf]
  cyberpanel-dotnet disable <domain>
  cyberpanel-dotnet redeploy [<domain>]
  cyberpanel-dotnet port <domain>
  cyberpanel-dotnet logs <domain> [--lines N|-n N] [-f]
  cyberpanel-dotnet check <domain>
  cyberpanel-dotnet fixmap <domain>

Examples:
  sudo cyberpanel-dotnet enable flezora.com --dll WebRTCVideoCall.dll
  sudo cyberpanel-dotnet redeploy flezora.com
  sudo cyberpanel-dotnet fixmap flezora.com
EOF
}

main(){
  [[ $# -ge 1 ]] || { usage; exit 1; }
  local cmd="$1"; shift || true
  case "$cmd" in
    enable)      cmd_enable "$@";;
    disable)     [[ $# -ge 1 ]] || err "Usage: disable <domain>"; cmd_disable "$@";;
    redeploy)    cmd_redeploy "$@";;
    port)        [[ $# -ge 1 ]] || err "Usage: port <domain>"; cmd_port "$@";;
    logs)        [[ $# -ge 1 ]] || err "Usage: logs <domain> [--lines N|-n N] [-f]"; cmd_logs "$@";;
    check)       [[ $# -ge 1 ]] || err "Usage: check <domain>"; cmd_check "$@";;
    fixmap)      [[ $# -ge 1 ]] || err "Usage: fixmap <domain>"; cmd_fixmap "$@";;
    -h|--help|help) usage;;
    *) err "Unknown command: $cmd";;
  esac
}

main "$@"
