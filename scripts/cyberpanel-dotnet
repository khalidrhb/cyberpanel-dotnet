#!/usr/bin/env bash
# cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel (OpenLiteSpeed)
# MIT © Mohd Khalid
set -Eeuo pipefail
shopt -s extglob nullglob

# ---------- UI ----------
red(){ echo -e "\e[31m$*\e[0m"; }
grn(){ echo -e "\e[32m$*\e[0m"; }
yel(){ echo -e "\e[33m$*\e[0m"; }
err(){ red "[ERROR] $*" 1>&2; exit 1; }
info(){ echo "[i] $*"; }
need(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1"; }

# ---------- Globals ----------
SYSTEMD_DIR="/etc/systemd/system"
ENV_DIR="/etc/dotnet-apps"
PORT_RANGE_START=${PORT_RANGE_START:-5100}
PORT_RANGE_END=${PORT_RANGE_END:-8999}

LSWS_ROOT=""; CONF_DIR=""; HTTPD_CONF=""; VHOSTS_DIR=""
MARK_BEGIN="# >>> cyberpanel-dotnet BEGIN"
MARK_END="# <<< cyberpanel-dotnet END"

sanitize_id(){ echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g; s/[.]/_/g'; }
service_name(){ local id; id=$(sanitize_id "$1"); echo "dotnet-app@${id}.service"; }
service_path(){ echo "$SYSTEMD_DIR/$(service_name "$1")"; }
envfile_path(){ local id; id=$(sanitize_id "$1"); echo "$ENV_DIR/${id}.env"; }

# ---------- OLS discovery ----------
_detect_lsws_root(){
  if [[ -n "${LSWS_ROOT:-}" && -x "${LSWS_ROOT}/bin/lswsctrl" ]]; then echo "$LSWS_ROOT"; return; fi
  [[ -x "/usr/local/lsws/bin/lswsctrl" ]] && { echo "/usr/local/lsws"; return; }
  if command -v lswsctrl >/dev/null 2>&1; then
    local p; p="$(command -v lswsctrl)"; p="$(readlink -f "$p" 2>/dev/null || echo "$p")"
    echo "${p%/bin/lswsctrl}"; return
  fi
  [[ -d "/usr/local/lsws" ]] && { echo "/usr/local/lsws"; return; }
  return 1
}
ols_paths(){
  LSWS_ROOT="$(_detect_lsws_root)" || err "OpenLiteSpeed not found"
  CONF_DIR="$LSWS_ROOT/conf"
  HTTPD_CONF="$CONF_DIR/httpd_config.conf"
  VHOSTS_DIR="$CONF_DIR/vhosts"
  [[ -f "$HTTPD_CONF" && -d "$VHOSTS_DIR" ]] || err "OLS conf missing under $CONF_DIR"
}
ols_reload(){
  [[ -x "$LSWS_ROOT/bin/lswsctrl" ]] && "$LSWS_ROOT/bin/lswsctrl" reload || true
  systemctl reload lsws 2>/dev/null || systemctl restart lsws 2>/dev/null || true
}

# ---------- Resolve vhost + vhost.conf path ----------
# Which virtualHost name is mapped to DOMAIN in httpd_config.conf?
vhname_for_domain(){
  local domain="$1"
  # Use grep + awk (mawk-safe). Pick first match.
  grep -inE '^[[:space:]]*map[[:space:]]+' "$HTTPD_CONF" \
    | grep -iE "(^|[[:space:]])$domain([[:space:]]|$)" \
    | awk '{print $2}' | head -n1
}

# If virtualHost <name> has a "configFile ..." line, resolve it to a full path.
configfile_for_vhname(){
  local vhname="$1"
  [[ -z "$vhname" ]] && return 1
  local raw
  raw="$(sed -n "/^[[:space:]]*virtualHost[[:space:]]\+$vhname[[:space:]]*{/,/^[[:space:]]*}/p" "$HTTPD_CONF" \
        | sed -n 's/^[[:space:]]*configFile[[:space:]]\+\(.*\)$/\1/p' | head -n1 | tr -d '"' )"
  [[ -z "$raw" ]] && return 1
  raw="${raw//\$SERVER_ROOT/$LSWS_ROOT}"
  raw="${raw//\$\{SERVER_ROOT\}/$LSWS_ROOT}"
  raw="${raw//\$VH_NAME/$vhname}"
  raw="${raw//\$\{VH_NAME\}/$vhname}"
  [[ "${raw:0:1}" != "/" ]] && raw="$LSWS_ROOT/$raw"
  echo "$raw"
}

# Return a list (space-separated) of vhost config files to edit for DOMAIN.
vhconf_candidates(){
  local domain="$1"
  local candidates=()
  local vhname conf
  vhname="$(vhname_for_domain "$domain" || true)"
  conf="$(configfile_for_vhname "$vhname" || true)"
  [[ -n "$conf" && -f "$conf" ]] && candidates+=("$conf")
  # folder-named fallbacks
  [[ -f "$VHOSTS_DIR/$vhname/vhost.conf"  ]] && candidates+=("$VHOSTS_DIR/$vhname/vhost.conf")
  [[ -f "$VHOSTS_DIR/$vhname/vhconf.conf" ]] && candidates+=("$VHOSTS_DIR/$vhname/vhconf.conf")
  [[ -f "$VHOSTS_DIR/$domain/vhost.conf"  ]] && candidates+=("$VHOSTS_DIR/$domain/vhost.conf")
  [[ -f "$VHOSTS_DIR/$domain/vhconf.conf" ]] && candidates+=("$VHOSTS_DIR/$domain/vhconf.conf")
  # de-dup
  echo "${candidates[@]}" | tr ' ' '\n' | awk '!x[$0]++' | paste -sd' ' -
}

# ---------- Docroot + DLL ----------
docroot_from_vhconf(){
  local vhconf="$1"
  local vhname; vhname="$(basename "$(dirname "$vhconf")")"
  local dr
  dr="$(sed -n 's/^[[:space:]]*docRoot[[:space:]]\+\(.*\)$/\1/p' "$vhconf" | head -n1 | tr -d '"' )"
  dr="${dr//\$SERVER_ROOT/$LSWS_ROOT}"; dr="${dr//\$\{SERVER_ROOT\}/$LSWS_ROOT}"
  dr="${dr//\$VH_NAME/$vhname}";       dr="${dr//\$\{VH_NAME\}/$vhname}"
  dr="${dr//\$VH_ROOT/}";              dr="${dr//\$\{VH_ROOT\}/}"
  dr="$(echo "$dr" | sed -E 's@//+@/@g')"
  [[ -z "$dr" || "$dr" == "/public_html" || "$dr" == "public_html" ]] && dr="/home/$vhname/public_html"
  echo "${dr%/}"
}
workdir_for_domain(){
  local domain="$1"
  local cand; cand="$(vhconf_candidates "$domain" | awk '{print $1}')" || true
  [[ -z "$cand" ]] && err "OpenLiteSpeed vhost for '$domain' not found. Create the site in CyberPanel."
  [[ -d "/home/$domain/public_html" ]] && { echo "/home/$domain/public_html"; return; }
  local dr; dr="$(docroot_from_vhconf "$cand")"
  [[ -d "$dr" ]] && { echo "$dr"; return; }
  local guess; guess="$(find /home -maxdepth 3 -type d -path "/home/*/public_html" 2>/dev/null | grep "/$domain/" -m1 || true)"
  [[ -n "$guess" ]] && { echo "$guess"; return; }
  err "Could not find document root for '$domain'."
}
resolve_dll_from_marker(){ [[ -f "$1/.dotnet" ]] && awk -F= '/^\s*DLL\s*=/ {print $2; exit}' "$1/.dotnet" | tr -d ' \t\r'; }
resolve_dll(){
  local dir="$1" dll="${2:-}" cand
  [[ -z "$dll" ]] && dll="$(resolve_dll_from_marker "$dir" || true)"
  [[ -z "$dll" ]] && err "--dll is required (or put DLL=YourApp.dll in $dir/.dotnet)"
  [[ "$dll" = /* && -f "$dll" ]] && { echo "$dll"; return; }
  for cand in "$dir/$dll" "$dir/publish/$dll" "$dir"/bin/*/*/publish/"$dll"; do [[ -f "$cand" ]] && { echo "$cand"; return; }; done
  cand="$(find "$dir" -maxdepth 2 -type f -name "$(basename "$dll")" -print -quit 2>/dev/null || true)"
  [[ -n "$cand" ]] && { echo "$cand"; return; }
  err "DLL '$dll' not found under '$dir'. Upload your published files."
}

# ---------- Ports / systemd ----------
port_in_use(){
  local p="$1"
  ss -ltnH 2>/dev/null | awk -v P="$p" '{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$P" \
  || netstat -tln 2>/dev/null | awk -v P="$p" '$6=="LISTEN"{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$P"
}
alloc_port(){
  local domain="$1" p span=$((PORT_RANGE_END-PORT_RANGE_START+1))
  local seed=$(( $(printf '%s' "$domain" | cksum | awk '{print $1}') % span + PORT_RANGE_START ))
  for ((p=seed; p<=PORT_RANGE_END; p++)); do ! port_in_use "$p" && { echo "$p"; return; }; done
  for ((p=PORT_RANGE_START; p<seed; p++)); do ! port_in_use "$p" && { echo "$p"; return; }; done
  err "No free port in $PORT_RANGE_START..$PORT_RANGE_END"
}
get_port_from_service(){
  local domain="$1" envf svc p
  envf="$(envfile_path "$domain")"
  [[ -f "$envf" ]] && { p="$(awk -F= '/^PORT=/{print $2; exit}' "$envf" | tr -d ' \t\r')"; [[ -n "$p" ]] && { echo "$p"; return; }; }
  svc="$(service_path "$domain")"
  [[ -f "$svc" ]] && { p="$(sed -n 's/^Environment=PORT=\([0-9]\+\).*$/\1/p' "$svc" | tail -n1)"; [[ -n "$p" ]] && { echo "$p"; return; }; }
  p="$(systemctl show "$(service_name "$domain")" -p Environment 2>/dev/null | sed -n 's/^Environment=.*PORT=\([0-9]\+\).*$/\1/p' | head -n1)"
  [[ -n "$p" ]] && echo "$p" || return 1
}

# ---------- OLS file edits ----------
remove_root_contexts(){
  # Remove any existing root context blocks and our markers (Perl; no env vars)
  local f="$1"
  perl -0777 -i -pe '
    s/^\s*context\s*\/\s*\{(?:[^{}]|\{[^{}]*\})*^\s*\}\s*\n?//gms;
    s/^# >>> cyberpanel-dotnet BEGIN.*?# <<< cyberpanel-dotnet END\s*\n?//gms;
  ' "$f"
}

inject_proxy_block(){
  local f="$1" port="$2"
  remove_root_contexts "$f"
  cat >>"$f" <<EOF
$MARK_BEGIN
context / {
  type                    proxy
  handler                 http://127.0.0.1:$port
  addDefaultCharset       off
  cacheEnable             0
  rewrite                 0
}
# Keep ACME static for SSL renewals
context /.well-known/acme-challenge/ {
  location                \$DOC_ROOT/.well-known/acme-challenge/
  allowBrowse             1
}
$MARK_END
EOF
}

# ---------- Commands ----------
cmd_check(){
  need grep; need sed; ols_paths
  local domain="$1"
  local vhname; vhname="$(vhname_for_domain "$domain" || true)"
  local files; files="$(vhconf_candidates "$domain" || true)"
  local docroot; docroot="$(workdir_for_domain "$domain" || true)"
  local port; port="$(get_port_from_service "$domain" || true)"
  echo "LSWS_ROOT=$LSWS_ROOT"
  echo "CONF_DIR=$CONF_DIR"
  echo "VHOSTS_DIR=$VHOSTS_DIR"
  echo "HTTPD_CONF=$HTTPD_CONF"
  echo "VHNAME=${vhname:-'(unknown)'}"
  echo "VHCONFS=${files:-'(none)'}"
  echo "DOCROOT=${docroot:-'(unknown)'}"
  echo "PORT=${port:-'(not assigned yet)'}"
}

cmd_port(){ ols_paths; get_port_from_service "$1"; }

cmd_logs(){
  local domain="$1"; shift || true
  local lines=200 follow=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --lines|-n) lines="$2"; shift 2;;
      -f|--follow) follow=1; shift;;
      *) break;;
    esac
  done
  [[ "$follow" -eq 1 ]] && journalctl -u "$(service_name "$domain")" -f || journalctl -u "$(service_name "$domain")" -n "$lines"
}

cmd_redeploy(){
  if [[ $# -eq 0 ]]; then
    systemctl list-units 'dotnet-app@*.service' --no-legend | awk '{print $1}' | while read -r u; do systemctl restart "$u" || true; done
    echo "Redeployed all"
  else
    systemctl restart "$(service_name "$1")"; echo "Redeployed $1"
  fi
}

cmd_disable(){
  ols_paths
  local domain="$1" f
  systemctl stop "$(service_name "$domain")" || true
  systemctl disable "$(service_name "$domain")" || true
  for f in $(vhconf_candidates "$domain"); do
    perl -0777 -i -pe 's/^# >>> cyberpanel-dotnet BEGIN.*?# <<< cyberpanel-dotnet END\s*\n?//gms' "$f" || true
  done
  ols_reload
  echo "Disabled $domain"
}

cmd_enable(){
  need grep; need sed; need perl; ols_paths

  local domain="" dll="" port=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dll) dll="$2"; shift 2;;
      --port) port="$2"; shift 2;;
      --vhconf) VHCONF_OVERRIDE="$2"; shift 2;; # accepted but unused in this lean build
      --help|-h) echo "Usage: cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N]"; return 0;;
      *) domain="$1"; shift;;
    esac
  done
  [[ -n "$domain" ]] || err "Usage: enable <domain> --dll YourApp.dll"

  local docroot dll_path uid user envf unit files
  docroot="$(workdir_for_domain "$domain")"
  dll_path="$(resolve_dll "$docroot" "$dll")"

  uid="$(stat -c '%u' "$docroot" 2>/dev/null || echo 0)"
  user="$(getent passwd "$uid" | cut -d: -f1 || true)"; [[ -z "$user" ]] && user="www-data"

  [[ -z "${port:-}" ]] && port="$(get_port_from_service "$domain" || true)"
  [[ -z "${port:-}" ]] && port="$(alloc_port "$domain")"

  mkdir -p "$ENV_DIR"
  envf="$(envfile_path "$domain")"
  cat >"$envf" <<EOF
DOMAIN=$domain
DOCROOT=$docroot
PORT=$port
USER=$user
DLL_PATH=$dll_path
EOF
  chmod 0644 "$envf"

  unit="$(service_name "$domain")"
  systemctl daemon-reload || true
  systemctl enable "$unit" >/dev/null 2>&1 || true
  systemctl restart "$unit"

  # Edit all plausible vhost files
  files="$(vhconf_candidates "$domain")"
  [[ -z "$files" ]] && err "Could not resolve vhost conf for $domain."
  for f in $files; do
    cp -a "$f" "$f.bak.$(date +%s)" || true
    inject_proxy_block "$f" "$port"
  done

  ols_reload

  grn "✅ Enabled $domain"
  echo "------------------------------------------------------------"
  echo "Public URL:    http(s)://$domain"
  for f in $files; do
    echo "Reverse proxy: ADDED in $f (OpenLiteSpeed)"
  done
  echo "Internal URL:  http://127.0.0.1:$port  (Kestrel)"
  echo "Systemd unit:  $(service_name "$domain")"
  echo "Env file:      $(envfile_path "$domain")"
  echo
  echo "Next steps:"
  echo " • Open your site:   https://$domain   (if SSL is configured in CyberPanel)"
  echo " • Live logs:        journalctl -u $(service_name "$domain") -f"
  echo " • Redeploy now:     sudo cyberpanel-dotnet redeploy $domain"
  echo " • Check detected:   sudo cyberpanel-dotnet check $domain"
  echo "------------------------------------------------------------"
}

usage(){
  cat <<EOF
cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel

Usage:
  cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N]
  cyberpanel-dotnet disable <domain>
  cyberpanel-dotnet redeploy [<domain>]
  cyberpanel-dotnet port <domain>
  cyberpanel-dotnet logs <domain> [--lines N|-n N] [-f]
  cyberpanel-dotnet check <domain>
EOF
}

main(){
  [[ $# -ge 1 ]] || { usage; exit 1; }
  local cmd="$1"; shift || true
  case "$cmd" in
    enable)   cmd_enable "$@";;
    disable)  [[ $# -ge 1 ]] || err "Usage: disable <domain>"; cmd_disable "$@";;
    redeploy) cmd_redeploy "$@";;
    port)     [[ $# -ge 1 ]] || err "Usage: port <domain>"; cmd_port "$@";;
    logs)     [[ $# -ge 1 ]] || err "Usage: logs <domain> [--lines N|-n N] [-f]"; cmd_logs "$@";;
    check)    [[ $# -ge 1 ]] || err "Usage: check <domain>"; cmd_check "$@";;
    -h|--help|help) usage;;
    *) err "Unknown command: $cmd";;
  esac
}
main "$@"
