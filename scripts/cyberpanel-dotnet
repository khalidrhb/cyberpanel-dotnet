#!/usr/bin/env bash
# cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel (OpenLiteSpeed)
# MIT © Mohd Khalid
set -Eeuo pipefail
shopt -s extglob nullglob

# ---------- UI ----------
red(){ echo -e "\e[31m$*\e[0m"; }
grn(){ echo -e "\e[32m$*\e[0m"; }
yel(){ echo -e "\e[33m$*\e[0m"; }
err(){ red "[ERROR] $*" 1>&2; exit 1; }
info(){ echo "[i] $*"; }
need(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1"; }

# ---------- Globals ----------
SYSTEMD_DIR="/etc/systemd/system"
ENV_DIR="/etc/dotnet-apps"
STATE_DIR="/etc/cyberpanel-dotnet"
PORT_RANGE_START=${PORT_RANGE_START:-5100}
PORT_RANGE_END=${PORT_RANGE_END:-8999}

LSWS_ROOT=""; CONF_DIR=""; HTTPD_CONF=""; VHOSTS_DIR=""
MARK_BEGIN="# >>> cyberpanel-dotnet BEGIN"
MARK_END="# <<< cyberpanel-dotnet END"
MARK_EXT_BEGIN="# >>> cyberpanel-dotnet EXTAPP BEGIN"
MARK_EXT_END="# <<< cyberpanel-dotnet EXTAPP END"

mkdir -p "$STATE_DIR" "$ENV_DIR"

# ---------- Helpers ----------
sanitize_id(){ echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g; s/[.]/_/g'; }
service_name(){ local id; id=$(sanitize_id "$1"); echo "dotnet-app@${id}.service"; }
service_path(){ echo "$SYSTEMD_DIR/$(service_name "$1")"; }
envfile_path(){ local id; id=$(sanitize_id "$1"); echo "$ENV_DIR/${id}.env"; }

# ---------- OpenLiteSpeed discovery ----------
_detect_lsws_root(){
  if [[ -n "${LSWS_ROOT:-}" && -x "${LSWS_ROOT}/bin/lswsctrl" ]]; then echo "$LSWS_ROOT"; return; fi
  [[ -x "/usr/local/lsws/bin/lswsctrl" ]] && { echo "/usr/local/lsws"; return; }
  if command -v lswsctrl >/dev/null 2>&1; then
    local p; p="$(command -v lswsctrl)"; p="$(readlink -f "$p" 2>/dev/null || echo "$p")"
    echo "${p%/bin/lswsctrl}"; return
  fi
  [[ -d "/usr/local/lsws" ]] && { echo "/usr/local/lsws"; return; }
  return 1
}
ols_paths(){
  LSWS_ROOT="$(_detect_lsws_root)" || err "OpenLiteSpeed not found"
  CONF_DIR="$LSWS_ROOT/conf"
  HTTPD_CONF="$CONF_DIR/httpd_config.conf"
  VHOSTS_DIR="$CONF_DIR/vhosts"
  [[ -f "$HTTPD_CONF" && -d "$VHOSTS_DIR" ]] || err "OLS conf missing under $CONF_DIR"
}
ols_reload(){
  [[ -x "$LSWS_ROOT/bin/lswsctrl" ]] && "$LSWS_ROOT/bin/lswsctrl" reload || true
  systemctl reload lsws 2>/dev/null || systemctl restart lsws 2>/dev/null || true
}

# ---------- vhost + docroot resolution ----------
_expand_vars(){
  local raw="${1:-}" vhconf="${2:-}"
  local vhname serverroot="$LSWS_ROOT" vhroot=""
  vhname="$(basename "$(dirname "$vhconf")")"
  vhroot="$(awk '/^[ \t]*vhRoot[ \t]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  vhroot="${vhroot%\"}"; vhroot="${vhroot#\"}"
  if [[ -n "$vhroot" ]]; then
    vhroot="${vhroot//\$SERVER_ROOT/$serverroot}"
    vhroot="${vhroot//\$\{SERVER_ROOT\}/$serverroot}"
    vhroot="${vhroot//\$VH_NAME/$vhname}"
    vhroot="${vhroot//\$\{VH_NAME\}/$vhname}"
  fi
  raw="${raw//\$VH_ROOT/$vhroot}"
  raw="${raw//\$\{VH_ROOT\}/$vhroot}"
  raw="${raw//\$SERVER_ROOT/$serverroot}"
  raw="${raw//\$\{SERVER_ROOT\}/$serverroot}"
  raw="${raw//\$VH_NAME/$vhname}"
  raw="${raw//\$\{VH_NAME\}/$vhname}"
  echo "$raw"
}

docroot_from_vhconf(){
  local vhconf="$1"
  local raw dr
  raw="$(awk '/^[ \t]*docRoot[ \t]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  raw="${raw%\"}"; raw="${raw#\"}"
  dr="$(_expand_vars "$raw" "$vhconf")"
  dr="$(echo "$dr" | sed -E 's@//+@/@g')"; dr="${dr%/}"
  if [[ -z "$dr" || "$dr" == "/public_html" || "$dr" == "public_html" || "$dr" =~ [$][A-Z_\{] ]]; then
    local vhname dguess
    vhname="$(basename "$(dirname "$vhconf")")"
    dguess="$(awk '
      /^[ \t]*vhDomain[ \t]+/{
        for(i=2;i<=NF;i++){ gsub(/,|"/,"",$i); if($i!=""){ print $i; exit } }
      }' "$vhconf" 2>/dev/null || true)"
    [[ -z "$dguess" || "$dguess" =~ ^[$] ]] && dguess="$vhname"
    dr="/home/$dguess/public_html"
  fi
  echo "$dr"
}

virt_name_for_domain(){
  # virtualHost name used by httpd_config.conf map lines for this domain
  local domain="$1"
  grep -inE '^[[:space:]]*map[[:space:]]+' "$HTTPD_CONF" \
    | grep -iE "(^|[[:space:]])$domain([[:space:]]|$)" \
    | awk '{print $2; exit}' 2>/dev/null || true
}

configfile_for_vh_name(){
  local vhname="$1"
  [[ -z "$vhname" ]] && { echo ""; return 1; }
  local raw
  raw="$(sed -n "/^[[:space:]]*virtualHost[[:space:]]\+$vhname[[:space:]]*{/,/^[[:space:]]*}/p" "$HTTPD_CONF" \
        | sed -n 's/^[[:space:]]*configFile[[:space:]]\+\(.*\)$/\1/p' | head -n1)"
  raw="${raw%\"}"; raw="${raw#\"}"
  [[ -z "$raw" ]] && { echo ""; return 1; }
  local exp="${raw//\$SERVER_ROOT/$LSWS_ROOT}"
  exp="${exp//\$\{SERVER_ROOT\}/$LSWS_ROOT}"
  exp="${exp//\$VH_NAME/$vhname}"
  exp="${exp//\$\{VH_NAME\}/$vhname}"
  [[ "${exp:0:1}" != "/" ]] && exp="$LSWS_ROOT/$exp"
  echo "$exp"
}

vhconf_for(){
  # Return the vhost conf file used for this domain.
  local domain="$1" override="${2:-}"
  [[ -n "$override" && -f "$override" ]] && { echo "$override"; return; }

  local vhname conf
  vhname="$(virt_name_for_domain "$domain" || true)"
  if [[ -n "$vhname" ]]; then
    conf="$(configfile_for_vh_name "$vhname" || true)"
    [[ -n "$conf" && -f "$conf" ]] && { echo "$conf"; return; }
    [[ -f "$VHOSTS_DIR/$vhname/vhost.conf"  ]] && { echo "$VHOSTS_DIR/$vhname/vhost.conf"; return; }
    [[ -f "$VHOSTS_DIR/$vhname/vhconf.conf" ]] && { echo "$VHOSTS_DIR/$vhname/vhconf.conf"; return; }
  fi

  [[ -f "$VHOSTS_DIR/$domain/vhost.conf"  ]] && { echo "$VHOSTS_DIR/$domain/vhost.conf"; return; }
  [[ -f "$VHOSTS_DIR/$domain/vhconf.conf" ]] && { echo "$VHOSTS_DIR/$domain/vhconf.conf"; return; }

  local f dr
  for f in "$VHOSTS_DIR"/*/vhost.conf "$VHOSTS_DIR"/*/vhconf.conf; do
    [[ -f "$f" ]] || continue
    if awk -v D="$domain" '
         /^[ \t]*vhDomain[ \t]+/ { line=$0; gsub(/[A-Z]/,"",line); d=D; gsub(/[A-Z]/,"",d); if (index(line,d)>0){ print "hit"; exit } }
       ' "$f" | grep -q hit; then
      echo "$f"; return
    fi
    dr="$(docroot_from_vhconf "$f" || true)"
    [[ -n "$dr" ]] && echo "$dr" | grep -qiE "/$domain(/|.*)public_html/?$" && { echo "$f"; return; }
  done

  err "OpenLiteSpeed vhost for '$domain' not found under $VHOSTS_DIR.
Hints:
  • Ensure the site exists in CyberPanel.
  • Or pass:  --vhconf /usr/local/lsws/conf/vhosts/<name>/(vhost|vhconf).conf"
}

workdir_for_domain(){
  local domain="$1" override="${2:-}" vh dr
  vh="$(vhconf_for "$domain" "$override")" || exit 1
  [[ -d "/home/$domain/public_html" ]] && { echo "/home/$domain/public_html"; return; }
  dr="$(docroot_from_vhconf "$vh" || true)"
  [[ -n "$dr" && -d "$dr" ]] && { echo "$dr"; return; }
  local guess
  guess="$(find /home -maxdepth 3 -type d -path "/home/*/public_html" 2>/dev/null | grep "/$domain/" -m1 || true)"
  [[ -n "$guess" ]] && { echo "$guess"; return; }
  err "Could not find document root for '$domain'. Ensure the website exists in CyberPanel."
}

# ---------- .NET / ports ----------
find_dotnet(){ command -v dotnet >/dev/null 2>&1 && command -v dotnet || return 1; }

port_in_use(){
  local p="$1"
  ss -ltnH 2>/dev/null | awk -v P="$p" '{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$P" \
  || netstat -tln 2>/dev/null | awk -v P="$p" '$6=="LISTEN"{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$P"
}
alloc_port(){
  local domain="$1" p span=$((PORT_RANGE_END-PORT_RANGE_START+1))
  local seed=$(( $(printf '%s' "$domain" | cksum | awk '{print $1}') % span + PORT_RANGE_START ))
  for ((p=seed; p<=PORT_RANGE_END; p++)); do ! port_in_use "$p" && { echo "$p"; return; }; done
  for ((p=PORT_RANGE_START; p<seed; p++)); do ! port_in_use "$p" && { echo "$p"; return; }; done
  err "No free port in $PORT_RANGE_START..$PORT_RANGE_END"
}
get_port_from_service(){
  local domain="$1" envf svc p
  envf="$(envfile_path "$domain")"
  [[ -f "$envf" ]] && { p="$(awk -F= '/^PORT=/{print $2; exit}' "$envf" | tr -d ' \t\r')"; [[ -n "$p" ]] && { echo "$p"; return; }; }
  svc="$(service_path "$domain")"
  [[ -f "$svc" ]] && { p="$(sed -n 's/^Environment=PORT=\([0-9]\+\).*$/\1/p' "$svc" | tail -n1)"; [[ -n "$p" ]] && { echo "$p"; return; }; }
  p="$(systemctl show "$(service_name "$domain")" -p Environment 2>/dev/null | sed -n 's/^Environment=.*PORT=\([0-9]\+\).*$/\1/p' | head -n1)"
  [[ -n "$p" ]] && echo "$p" || return 1
}

resolve_dll_from_marker(){ [[ -f "$1/.dotnet" ]] && awk -F= '/^\s*DLL\s*=/ {print $2; exit}' "$1/.dotnet" | tr -d ' \t\r'; }
resolve_dll(){
  local dir="$1" dll="${2:-}" cand
  [[ -z "$dll" ]] && dll="$(resolve_dll_from_marker "$dir" || true)"
  [[ -z "$dll" ]] && err "--dll is required (or set DLL=YourApp.dll in $dir/.dotnet)"
  [[ "$dll" = /* && -f "$dll" ]] && { echo "$dll"; return; }
  for cand in "$dir/$dll" "$dir/publish/$dll" "$dir"/bin/*/*/publish/"$dll"; do [[ -f "$cand" ]] && { echo "$cand"; return; }; done
  cand="$(find "$dir" -maxdepth 2 -type f -name "$(basename "$dll")" -print -quit 2>/dev/null || true)"
  [[ -n "$cand" ]] && { echo "$cand"; return; }
  err "DLL '$dll' not found under '$dir'. Upload your published files."
}

# ---------- OLS editing ----------
remove_root_contexts(){
  local vhconf="$1"
  awk '
    BEGIN{depth=0; inroot=0}
    /^[ \t]*context[ \t]*\/[ \t]*\{/ { inroot=1; depth=1; next }
    inroot==1 {
      for(i=1;i<=length($0);i++){
        c=substr($0,i,1)
        if(c=="{")depth++
        else if(c=="}"){ depth--; if(depth==0){ inroot=0; next } }
      }
      next
    }
    { print }
  ' "$vhconf" > "$vhconf.__no_root__" && mv "$vhconf.__no_root__" "$vhconf"
}

ensure_virtualhost_enable(){
  # Make sure virtualHost <name> has "enable 1" in httpd_config.conf
  local vhname="$1" tmp="$HTTPD_CONF.__vh__"
  cp -a "$HTTPD_CONF" "$HTTPD_CONF.bak.$(date +%s)"
  awk -v N="$vhname" '
    BEGIN{in=0; done=0}
    /^[ \t]*virtualHost[ \t]+/ {
      if ($2==N) { in=1; print; next }
    }
    in==1 && /^[ \t]*enable[ \t]+0/ { sub(/enable[ \t]+0/,"enable                 1"); print; done=1; next }
    in==1 && /^[ \t]*enable[ \t]+1/ { print; done=1; next }
    in==1 && /^[ \t]*configFile[ \t]+/ {
      if(done==0){ print "  enable                 1"; done=1 }
      print; next
    }
    in==1 && /^[ \t]*}/ {
      if(done==0) print "  enable                 1"
      print; in=0; next
    }
    { print }
  ' "$HTTPD_CONF" > "$tmp" && mv "$tmp" "$HTTPD_CONF"
}

ensure_extapp_and_proxy(){
  # Safer: extprocessor + proxyExtAppName context
  local vhconf="$1" vhname="$2" port="$3"
  local id; id="$(sanitize_id "$vhname")"

  # clean out previous blocks and any existing root contexts
  sed -i "/^$MARK_EXT_BEGIN/,/^$MARK_EXT_END/d" "$vhconf" || true
  sed -i "/^$MARK_BEGIN/,/^$MARK_END/d" "$vhconf" || true
  remove_root_contexts "$vhconf"

  cat >>"$vhconf" <<EOF
$MARK_EXT_BEGIN
extprocessor cpdotnet-$id {
  type                    proxy
  address                 127.0.0.1:$port
  maxConns                100
  pcKeepAliveTimeout      60
  initTimeout             60
  retryTimeout            0
  respBuffer              0
}
$MARK_EXT_END
$MARK_BEGIN
context / {
  type                    proxy
  proxyExtAppName         cpdotnet-$id
  addDefaultCharset       off
  cacheEnable             0
  rewrite                 0
}
# Keep ACME static for SSL renewals
context /.well-known/acme-challenge/ {
  location                \$DOC_ROOT/.well-known/acme-challenge/
  allowBrowse             1
}
$MARK_END
EOF
}

ensure_vhDomain(){
  local vhconf="$1" domain="$2"
  if grep -qiE '^[[:space:]]*vhDomain[[:space:]]+' "$vhconf"; then
    local cur rest merged
    cur="$(grep -iE '^[[:space:]]*vhDomain[[:space:]]+' "$vhconf" | head -n1)"
    rest="${cur#*vhDomain}"; rest="$(echo "$rest" | tr -d '\r' | tr ',' ' ' | tr '[:upper:]' '[:lower:]')"
    merged="$(printf '%s\n%s\nwww.%s\n' "$rest" "$domain" "$domain" | tr ' ' '\n' | sed '/^$/d' | sort -u | paste -sd',' -)"
    awk -v NEW="vhDomain $merged" '
      BEGIN{done=0}
      { if (!done && $0 ~ /^[[:space:]]*vhDomain[[:space:]]+/) { print NEW; done=1 } else print $0 }
    ' "$vhconf" > "$vhconf.__vhd__" && mv "$vhconf.__vhd__" "$vhconf"
  else
    printf '\n# added by cyberpanel-dotnet\nvhDomain %s, %s\n' "$domain" "www.$domain" >> "$vhconf"
  fi
}

fix_listener_mappings(){
  # Put our mapping first and drop duplicates for this domain.
  local domain="$1" vhname="$2" httpd="$HTTPD_CONF"
  [[ -f "$httpd" ]] || err "httpd_config.conf not found"
  cp -a "$httpd" "$httpd.bak.$(date +%s)"
  awk -v VH="$vhname" -v D1="$domain" -v D2="www.$domain" '
    BEGIN { inblk=0; m=0 }
    {
      line=$0
      if (line ~ /^[ \t]*listener[ \t]+/) { inblk=1; m=0; print line; next }
      if (inblk==1 && line ~ /^[ \t]*address[ \t]+/) { print line; next }
      if (inblk==1 && line ~ /^[ \t]*secure[ \t]+/)  { print line; next }
      if (inblk==1 && line ~ /^[ \t]*map[ \t]+/) { maps[++m]=line; next }
      if (inblk==1 && line ~ /^[ \t]*}/) {
        print "  map  " VH "  " D1 " " D2
        for (i=1; i<=m; i++) {
          low=maps[i]; gsub(/[A-Z]/,"",low)
          d1=D1; d2=D2; gsub(/[A-Z]/,"",d1); gsub(/[A-Z]/,"",d2)
          if (index(low,d1)>0 || index(low,d2)>0) continue
          print maps[i]
        }
        inblk=0; m=0; print line; next
      }
      print line
    }
  ' "$httpd" > "$httpd.__new__" && mv "$httpd.__new__" "$httpd"
  ols_reload
}

# ---------- Commands ----------
cmd_check(){
  need awk; need sed; need grep; ols_paths
  local domain="$1" vhconf docroot p
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  docroot="$(docroot_from_vhconf "$vhconf" || true)"; [[ -z "$docroot" ]] && docroot="/home/$domain/public_html"
  echo "LSWS_ROOT=$LSWS_ROOT"
  echo "CONF_DIR=$CONF_DIR"
  echo "VHOSTS_DIR=$VHOSTS_DIR"
  echo "HTTPD_CONF=$HTTPD_CONF"
  echo "VHCONF=$vhconf"
  echo "DOCROOT=$docroot"
  p="$(get_port_from_service "$domain" || true)"
  echo "PORT=${p:-'(not assigned yet)'}"
}

cmd_port(){ ols_paths; get_port_from_service "$1"; }

cmd_logs(){
  local domain="$1"; shift || true
  local lines=200 follow=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --lines|-n) lines="$2"; shift 2;;
      -f|--follow) follow=1; shift;;
      *) break;;
    esac
  done
  [[ "$follow" -eq 1 ]] && journalctl -u "$(service_name "$domain")" -f || journalctl -u "$(service_name "$domain")" -n "$lines"
}

cmd_redeploy(){
  if [[ $# -eq 0 ]]; then
    systemctl list-units 'dotnet-app@*.service' --no-legend | awk '{print $1}' | while read -r u; do systemctl restart "$u" || true; done
    echo "Redeployed all"
  else
    systemctl restart "$(service_name "$1")"; echo "Redeployed $1"
  fi
}

cmd_disable(){
  ols_paths
  local domain="$1" vhconf
  systemctl stop "$(service_name "$domain")" || true
  systemctl disable "$(service_name "$domain")" || true
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  sed -i "/^$MARK_BEGIN/,/^$MARK_END/d" "$vhconf" || true
  sed -i "/^$MARK_EXT_BEGIN/,/^$MARK_EXT_END/d" "$vhconf" || true
  remove_root_contexts "$vhconf" || true
  ols_reload
  echo "Disabled $domain"
}

cmd_enable(){
  need awk; need sed; need grep; ols_paths
  local domain="" dll="" port="" override_vh=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dll) dll="$2"; shift 2;;
      --port) port="$2"; shift 2;;
      --vhconf) override_vh="$2"; shift 2;;
      --help|-h) echo "Usage: cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N] [--vhconf /path/to/(vhost|vhconf).conf]"; return 0;;
      *) domain="$1"; shift;;
    esac
  done
  [[ -n "$domain" ]] || err "Usage: enable <domain> --dll YourApp.dll"

  local vhconf docroot dll_path user uid envf unit vhname_map conf_map also=""
  vhconf="$(vhconf_for "$domain" "$override_vh")"
  docroot="$(workdir_for_domain "$domain" "$vhconf")"
  dll_path="$(resolve_dll "$docroot" "$dll")"

  uid="$(stat -c '%u' "$docroot" 2>/dev/null || echo 0)"
  user="$(getent passwd "$uid" | cut -d: -f1 || true)"; [[ -z "$user" ]] && user="www-data"

  if [[ -z "${port:-}" ]]; then port="$(get_port_from_service "$domain" || true)"; [[ -z "$port" ]] && port="$(alloc_port "$domain")"; fi

  envf="$(envfile_path "$domain")"
  cat >"$envf" <<EOF
DOMAIN=$domain
DOCROOT=$docroot
PORT=$port
USER=$user
DLL_PATH=$dll_path
EOF
  chmod 0644 "$envf"

  unit="$(service_name "$domain")"
  systemctl daemon-reload || true
  systemctl enable "$unit" >/dev/null 2>&1 || true
  systemctl restart "$unit"

  # Resolve mapped virtualHost name + conf from httpd_config.conf
  vhname_map="$(virt_name_for_domain "$domain" || true)"
  conf_map="$(configfile_for_vh_name "$vhname_map" || true)"

  # Ensure vhost enabled (defensive)
  [[ -n "$vhname_map" ]] && ensure_virtualhost_enable "$vhname_map"

  # Inject into resolved vhconf
  ensure_vhDomain "$vhconf" "$domain"
  ensure_extapp_and_proxy "$vhconf" "${vhname_map:-$(basename "$(dirname "$vhconf")")}" "$port"

  # If httpd_config.conf maps to a different file, inject there too.
  if [[ -n "$conf_map" && -f "$conf_map" && "$conf_map" != "$vhconf" ]]; then
    ensure_vhDomain "$conf_map" "$domain"
    ensure_extapp_and_proxy "$conf_map" "$vhname_map" "$port"
    also="$conf_map"
  fi

  # Fix listener maps to our virtualHost name
  [[ -z "$vhname_map" ]] && vhname_map="$(basename "$(dirname "$vhconf")")"
  fix_listener_mappings "$domain" "$vhname_map"
  ols_reload

  grn "✅ Enabled $domain"
  echo "------------------------------------------------------------"
  echo "Public URL:    http(s)://$domain"
  echo "Reverse proxy: ADDED in $vhconf (OpenLiteSpeed)"
  [[ -n "$also" ]] && echo "Also touched:   $also (mapped by httpd_config.conf)"
  echo "Internal URL:  http://127.0.0.1:$port  (Kestrel)"
  echo "Systemd unit:  $(service_name "$domain")"
  echo "Env file:      $(envfile_path "$domain")"
  echo
  echo "Next steps:"
  echo " • Open your site:   https://$domain   (if SSL is configured in CyberPanel)"
  echo " • Live logs:        journalctl -u $(service_name "$domain") -f"
  echo " • Redeploy now:     sudo cyberpanel-dotnet redeploy $domain"
  echo " • Check detected:   sudo cyberpanel-dotnet check $domain"
  echo "------------------------------------------------------------"
}

cmd_fixmap(){
  ols_paths
  local domain="$1" vhconf vhname
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  vhname="$(virt_name_for_domain "$domain" || true)"
  [[ -z "$vhname" ]] && vhname="$(basename "$(dirname "$vhconf")")"
  ensure_virtualhost_enable "$vhname"
  fix_listener_mappings "$domain" "$vhname"
}

# ---------- CLI ----------
usage(){
  cat <<EOF
cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel

Usage:
  cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N] [--vhconf /path/to/(vhost|vhconf).conf]
  cyberpanel-dotnet disable <domain>
  cyberpanel-dotnet redeploy [<domain>]
  cyberpanel-dotnet port <domain>
  cyberpanel-dotnet logs <domain> [--lines N|-n N] [-f]
  cyberpanel-dotnet check <domain>
  cyberpanel-dotnet fixmap <domain>
EOF
}
main(){
  [[ $# -ge 1 ]] || { usage; exit 1; }
  local cmd="$1"; shift || true
  case "$cmd" in
    enable)   cmd_enable "$@";;
    disable)  [[ $# -ge 1 ]] || err "Usage: disable <domain>"; cmd_disable "$@";;
    redeploy) cmd_redeploy "$@";;
    port)     [[ $# -ge 1 ]] || err "Usage: port <domain>"; cmd_port "$@";;
    logs)     [[ $# -ge 1 ]] || err "Usage: logs <domain> [--lines N|-n N] [-f]"; cmd_logs "$@";;
    check)    [[ $# -ge 1 ]] || err "Usage: check <domain>"; cmd_check "$@";;
    fixmap)   [[ $# -ge 1 ]] || err "Usage: fixmap <domain>"; cmd_fixmap "$@";;
    -h|--help|help) usage;;
    *) err "Unknown command: $cmd";;
  esac
}
main "$@"
