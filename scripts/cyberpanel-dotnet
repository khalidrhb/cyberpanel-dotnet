#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s extglob

# ---------- UI helpers ----------
red(){ echo -e "\e[31m$*\e[0m"; }
grn(){ echo -e "\e[32m$*\e[0m"; }
yel(){ echo -e "\e[33m$*\e[0m"; }
err(){ red "[ERROR] $*" 1>&2; exit 1; }
info(){ echo "[i] $*"; }
sudo_ok(){ [[ ${EUID:-$(id -u)} -eq 0 ]] || err "Run as root (sudo)."; }
need(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1 (please install it)"; }

# ---------- Globals ----------
SYSTEMD_DIR="/etc/systemd/system"
ENV_DIR="/etc/dotnet-apps"
STATE_DIR="/etc/cyberpanel-dotnet"
PORT_RANGE_START=${PORT_RANGE_START:-5100}
PORT_RANGE_END=${PORT_RANGE_END:-8999}
MARK_BEGIN="# >>> cyberpanel-dotnet BEGIN"
MARK_END="# <<< cyberpanel-dotnet END"

LSWS_ROOT=""
VHOSTS_DIR=""
CONF_DIR=""

mkdir -p "$STATE_DIR" "$ENV_DIR"

# ---------- ID helpers ----------
sanitize_id(){ echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g; s/[.]/_/g'; }
service_name(){ local id; id=$(sanitize_id "$1"); echo "dotnet-app@${id}.service"; }
service_path(){ echo "$SYSTEMD_DIR/$(service_name "$1")"; }
envfile_path(){ local id; id=$(sanitize_id "$1"); echo "$ENV_DIR/${id}.env"; }

# ---------- OpenLiteSpeed discovery ----------
_detect_lsws_root(){
  if [[ -n "${LSWS_ROOT:-}" && -x "${LSWS_ROOT}/bin/lswsctrl" ]]; then echo "$LSWS_ROOT"; return; fi
  if [[ -x "/usr/local/lsws/bin/lswsctrl" ]]; then echo "/usr/local/lsws"; return; fi
  if command -v lswsctrl >/dev/null 2>&1; then
    local p; p=$(command -v lswsctrl)
    p=$(readlink -f "$p" 2>/dev/null || echo "$p")
    echo "${p%/bin/lswsctrl}"; return
  fi
  if [[ -d "/usr/local/lsws" ]]; then echo "/usr/local/lsws"; return; fi
  return 1
}

trim_slash(){ local p="${1:-}"; p="${p%/}"; echo "$p"; }

# Expand $VH_ROOT/$SERVER_ROOT/$VH_NAME inside a vhost conf
_expand_vars(){
  local raw="${1:-}" vhconf="${2:-}"
  local vhroot="" vhname="" serverroot="$LSWS_ROOT"

  # derive vhost name from path .../vhosts/<name>/vhconf.conf
  vhname="$(basename "$(dirname "$vhconf")")"

  # get vhRoot if present
  vhroot="$(awk '/^[[:space:]]*vhRoot[[:space:]]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  vhroot="${vhroot%\"}"; vhroot="${vhroot#\"}"

  # replace known vars
  raw="${raw//\$VH_ROOT/$vhroot}"
  raw="${raw//\$SERVER_ROOT/$serverroot}"
  raw="${raw//\$VH_NAME/$vhname}"
  echo "$raw"
}

# Resolve docRoot from a vhconf, expanding variables
docroot_from_vhconf(){
  local vhconf="$1"
  local dr; dr="$(awk '/^[[:space:]]*docRoot[[:space:]]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  dr="${dr%\"}"; dr="${dr#\"}"
  [[ -z "$dr" ]] && return 1
  dr="$(_expand_vars "$dr" "$vhconf")"
  dr="${dr%\"}"; dr="${dr#\"}"
  dr="$(trim_slash "$dr")"
  [[ -n "$dr" ]] && echo "$dr" && return 0
  return 1
}

# Parse listener "map" lines anywhere in $CONF_DIR to resolve domain -> vhost name
_vhname_from_map(){
  local domain="$1"
  local f line name
  shopt -s nullglob
  while IFS= read -r -d '' f; do
    while IFS= read -r line; do
      # lines like: map   myVHost   flezora.com,www.flezora.com  (or space/comma separated)
      echo "$line" | grep -qi -- "$domain" || continue
      name=$(awk 'BEGIN{IGNORECASE=1}
        /^[[:space:]]*map[[:space:]]+/ {
          for(i=1;i<=NF;i++){
            if(tolower($i)=="map"){ if(i+1<=NF){ print $(i+1); exit } }
          }
        }' <<<"$line")
      if [[ -n "$name" ]]; then
        echo "$name"; return 0
      fi
    done < <(grep -iE '^[[:space:]]*map[[:space:]]+' "$f" 2>/dev/null || true)
  done < <(find "$CONF_DIR" -type f -name "*.conf" -print0 2>/dev/null)
  return 1
}

# Robust vhost finder (safe for set -u):
#  1) exact folder match: $VHOSTS_DIR/<domain>/vhconf.conf
#  2) listener map lines -> vhost name
#  3) search by docRoot == /home/<domain>/public_html (expands $VH_ROOT etc.) across $VHOSTS_DIR + $CONF_DIR
#  4) docRoot contains the domain AND ends with public_html
#  5) path contains the domain
#  6) final heuristic: if exactly 1 non-Example vhost exists, use it
#  7) manual override via 2nd param
vhconf_for(){
  local domain="$1"
  local override="${2:-}"
  if [[ -n "$override" && -f "$override" ]]; then echo "$override"; return; fi

  local candidate="" exact_dr hit_sub="" hit_path=""
  exact_dr="$(trim_slash "/home/$domain/public_html")"

  # 1) exact folder match
  candidate="$VHOSTS_DIR/$domain/vhconf.conf"
  if [[ -f "$candidate" ]]; then echo "$candidate"; return; fi

  # 2) listener map -> vhName
  local vhname=""
  if vhname="$(_vhname_from_map "$domain" || true)"; then
    if [[ -n "$vhname" ]]; then
      candidate="$VHOSTS_DIR/$vhname/vhconf.conf"
      if [[ -f "$candidate" ]]; then echo "$candidate"; return; fi
    fi
  fi

  # 3/4/5) scan all vhconfs
  local d f dr
  for d in "$VHOSTS_DIR" "$CONF_DIR"; do
    [[ -d "$d" ]] || continue
    while IFS= read -r -d '' f; do
      dr="$(docroot_from_vhconf "$f" || true)"
      # exact match of expanded docRoot
      if [[ -n "$dr" && "$(trim_slash "$dr")" == "$exact_dr" ]]; then
        echo "$f"; return
      fi
      # loose: expanded docRoot mentions domain + public_html
      if [[ -z "$hit_sub" && -n "$dr" ]]; then
        if echo "$dr" | grep -qiE "/${domain}(/|.*)public_html/?$"; then
          hit_sub="$f"
        fi
      fi
      # path contains domain
      if [[ -z "$hit_path" ]]; then
        if echo "$f" | grep -qi "/${domain}.*vhconf\.conf$"; then
          hit_path="$f"
        fi
      fi
    done < <(find "$d" -type f -name 'vhconf.conf' -print0 2>/dev/null)
  done

  if [[ -n "$hit_sub" ]]; then echo "$hit_sub"; return; fi
  if [[ -n "$hit_path" ]]; then echo "$hit_path"; return; fi

  # 6) heuristic: if there is exactly 1 non-Example vhost, use it
  local one="" count=0
  while IFS= read -r f; do
    [[ "$f" == *"/Example/"* ]] && continue
    count=$((count+1)); one="$f"
  done < <(find "$VHOSTS_DIR" -maxdepth 2 -type f -name 'vhconf.conf' 2>/dev/null)
  if (( count == 1 )); then echo "$one"; return; fi

  err "OpenLiteSpeed vhost for '$domain' not found under $VHOSTS_DIR or $CONF_DIR.
Hints:
  • Ensure the site exists in CyberPanel.
  • Or pass an explicit file path:  --vhconf /usr/local/lsws/conf/vhosts/<name>/vhconf.conf"
}

workdir_for_domain(){
  local domain="$1"; local vh; vh=$(vhconf_for "$domain" "${2:-}") || exit 1
  if dr=$(docroot_from_vhconf "$vh"); then echo "$dr"; return; fi
  if [[ -d "/home/$domain/public_html" ]]; then echo "/home/$domain/public_html"; return; fi
  local guess; guess=$(find /home -maxdepth 3 -type d -path "/home/*/public_html" -printf '%p\n' 2>/dev/null | grep "/$domain/" -m1 || true)
  [[ -n "$guess" ]] || err "Could not find document root for '$domain'. Ensure the website exists and try again."
  echo "$guess"
}

# ---------- dotnet + port helpers ----------
find_dotnet(){ command -v dotnet >/dev/null 2>&1 && command -v dotnet || return 1; }

get_port_from_service(){
  local svc_path; svc_path=$(service_path "$1")
  [[ -f "$svc_path" ]] || return 1
  grep -E '^Environment=PORT=' "$svc_path" | sed -E 's/.*PORT=([0-9]+).*/\1/' | tail -n1 || \
  grep -E '^Environment=ASPNETCORE_URLS=' "$svc_path" | sed -E 's/.*:([0-9]+)\s*$/\1/' | tail -n1
}

port_in_use(){ ss -ltnH | awk '{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$1"; }
alloc_port(){
  local domain="$1"
  local seed=$(( ( $(echo -n "$domain" | md5sum | cut -c1-6 | tr 'a-f' '1-6') % 1000 ) + PORT_RANGE_START ))
  local p
  for ((p=seed; p<=PORT_RANGE_END; p++)); do
    if ! port_in_use "$p"; then echo "$p"; return; fi
  done
  err "No free port in $PORT_RANGE_START..$PORT_RANGE_END"
}

resolve_dll_from_marker(){
  local workdir="$1"
  if [[ -f "$workdir/.dotnet" ]]; then
    local dll; dll=$(awk -F= '/^\s*DLL\s*=/{print $2; exit}' "$workdir/.dotnet" | tr -d ' \t\r')
    [[ -n "$dll" ]] && echo "$dll" && return 0
  fi
  return 1
}

resolve_dll(){
  local workdir="$1"; local dll="${2:-}"
  if [[ -z "$dll" ]]; then
    if dll=$(resolve_dll_from_marker "$workdir"); then :; else err "--dll <App.dll> is required (or put DLL=YourApp.dll)"; fi
  fi
  if [[ "$dll" = /* && -f "$dll" ]]; then echo "$dll"; return; fi
  if [[ -f "$workdir/$dll" ]]; then echo "$workdir/$dll"; return; fi
  if [[ -d "$workdir" ]]; then
    local found; found=$(find "$workdir" -maxdepth 2 -type f -name "$(basename "$dll")" -print -quit || true)
    [[ -n "$found" ]] && echo "$found" && return
  fi
  err "DLL '$dll' not found under '$workdir'. Upload your published files to the site's document root."
}

# ---------- OLS integration ----------
ols_reload(){
  if [[ -x "$LSWS_ROOT/bin/lswsctrl" ]]; then "$LSWS_ROOT/bin/lswsctrl" reload || true; fi
  systemctl reload lsws 2>/dev/null || systemctl restart lsws 2>/dev/null || true
}

inject_proxy_context(){
  local vhconf="$1" port="$2"; local tmp
  [[ -f "$vhconf" ]] || err "vhconf missing: $vhconf"
  cp -a "$vhconf" "$vhconf.bak.$(date +%s)"
  tmp=$(mktemp)
  awk -v B="$MARK_BEGIN" -v E="$MARK_END" 'BEGIN{del=0} $0~B{del=1; next} $0~E{del=0; next} {if(!del) print $0}' "$vhconf" > "$tmp"
  {
    echo "$MARK_BEGIN"
    echo "context / {"
    echo "  type                    proxy"
    echo "  handler                 http://127.0.0.1:$port"
    echo "  addDefaultCharset       off"
    echo "  maxConns                256"
    echo "  rewrite                 0"
    echo "  cacheEnable             0"
    echo "}"
    echo "$MARK_END"
  } >> "$tmp"
  mv "$tmp" "$vhconf"
}

remove_proxy_context(){
  local vhconf="$1"; [[ -f "$vhconf" ]] || return 0
  cp -a "$vhconf" "$vhconf.bak.$(date +%s)"
  awk -v B="$MARK_BEGIN" -v E="$MARK_END" 'BEGIN{del=0} $0~B{del=1; next} $0~E{del=0; next} {if(!del) print $0}' "$vhconf" > "$vhconf.tmp"
  mv "$vhconf.tmp" "$vhconf"
}

# ---------- systemd ----------
create_service(){
  local domain="$1" workdir="$2" port="$3" absdll="$4"; l
