#!/usr/bin/env bash
# cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel (OpenLiteSpeed)
# MIT © Mohd Khalid
set -Eeuo pipefail
shopt -s extglob nullglob

# ------------ UI ------------
red(){ echo -e "\e[31m$*\e[0m"; }
grn(){ echo -e "\e[32m$*\e[0m"; }
yel(){ echo -e "\e[33m$*\e[0m"; }
err(){ red "[ERROR] $*" 1>&2; exit 1; }
info(){ echo "[i] $*"; }
need(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1"; }

# ------------ Globals ------------
SYSTEMD_DIR="/etc/systemd/system"
ENV_DIR="/etc/dotnet-apps"
STATE_DIR="/etc/cyberpanel-dotnet"
PORT_RANGE_START=${PORT_RANGE_START:-5100}
PORT_RANGE_END=${PORT_RANGE_END:-8999}

LSWS_ROOT=""; CONF_DIR=""; HTTPD_CONF=""; VHOSTS_DIR=""
MARK_BEGIN="# >>> cyberpanel-dotnet BEGIN"
MARK_END="# <<< cyberpanel-dotnet END"
MARK_EXT_BEGIN="# >>> cyberpanel-dotnet EXTAPP BEGIN"
MARK_EXT_END="# <<< cyberpanel-dotnet EXTAPP END"

mkdir -p "$STATE_DIR" "$ENV_DIR"

sanitize_id(){ echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g; s/[.]/_/g'; }
service_name(){ local id; id=$(sanitize_id "$1"); echo "dotnet-app@${id}.service"; }
service_path(){ echo "$SYSTEMD_DIR/$(service_name "$1")"; }
envfile_path(){ local id; id=$(sanitize_id "$1"); echo "$ENV_DIR/${id}.env"; }

# ------------ OLS discovery ------------
_detect_lsws_root(){
  if [[ -n "${LSWS_ROOT:-}" && -x "${LSWS_ROOT}/bin/lswsctrl" ]]; then echo "$LSWS_ROOT"; return; fi
  [[ -x "/usr/local/lsws/bin/lswsctrl" ]] && { echo "/usr/local/lsws"; return; }
  if command -v lswsctrl >/dev/null 2>&1; then
    local p; p="$(command -v lswsctrl)"; p="$(readlink -f "$p" 2>/dev/null || echo "$p")"
    echo "${p%/bin/lswsctrl}"; return
  fi
  [[ -d "/usr/local/lsws" ]] && { echo "/usr/local/lsws"; return; }
  return 1
}
ols_paths(){
  LSWS_ROOT="$(_detect_lsws_root)" || err "OpenLiteSpeed not found"
  CONF_DIR="$LSWS_ROOT/conf"
  HTTPD_CONF="$CONF_DIR/httpd_config.conf"
  VHOSTS_DIR="$CONF_DIR/vhosts"
  [[ -f "$HTTPD_CONF" && -d "$VHOSTS_DIR" ]] || err "OLS conf missing under $CONF_DIR"
}
ols_reload(){
  [[ -x "$LSWS_ROOT/bin/lswsctrl" ]] && "$LSWS_ROOT/bin/lswsctrl" reload || true
  systemctl reload lsws 2>/dev/null || systemctl restart lsws 2>/dev/null || true
}

# ------------ VirtualHost + DocRoot resolution (Perl only) ------------
virt_name_for_domain(){
  local domain="$1"
  # Print the *first* mapping vhost name for the domain
  perl -ne '
    BEGIN { $d = lc($ENV{D}); }
    if ( /^\s*map\s+(\S+)\s+(.*)$/i ) {
      my ($vh,$rest)=($1,$2); $_=lc($rest);
      if ( /\b\Q$d\E\b/ ) { print "$vh\n"; exit 0 }
    }
  ' D="$domain" "$HTTPD_CONF" || true
}

configfile_for_vh_name(){
  local vhname="$1"
  perl -0777 -ne '
    BEGIN{ $vh = $ENV{VH}; $found=0 }
    if ( s/^\s*virtualHost\s+\Q$vh\E\s*\{(.*?)^\s*\}//ms ) {
      my $body=$1;
      if ($body =~ /^\s*configFile\s+(.*)$/m){
        my $cf=$1; $cf =~ s/^"|"$//g;
        $cf =~ s/\$SERVER_ROOT/'"$LSWS_ROOT"'/g;
        $cf =~ s/\$\{SERVER_ROOT\}/'"$LSWS_ROOT"'/g;
        $cf =~ s/\$VH_NAME/$vh/g;
        $cf =~ s/\$\{VH_NAME\}/$vh/g;
        if ($cf !~ m{^/}) { $cf = "'"$LSWS_ROOT"'/$cf" }
        print "$cf\n"; exit 0;
      }
    }
  ' VH="$vhname" "$HTTPD_CONF" || true
}

vhconf_for(){
  local domain="$1" override="${2:-}"
  [[ -n "$override" && -f "$override" ]] && { echo "$override"; return; }

  local vhname conf
  vhname="$(virt_name_for_domain "$domain" || true)"
  if [[ -n "$vhname" ]]; then
    conf="$(configfile_for_vh_name "$vhname" || true)"
    [[ -n "$conf" && -f "$conf" ]] && { echo "$conf"; return; }
    [[ -f "$VHOSTS_DIR/$vhname/vhost.conf"  ]] && { echo "$VHOSTS_DIR/$vhname/vhost.conf"; return; }
    [[ -f "$VHOSTS_DIR/$vhname/vhconf.conf" ]] && { echo "$VHOSTS_DIR/$vhname/vhconf.conf"; return; }
  fi
  [[ -f "$VHOSTS_DIR/$domain/vhost.conf"  ]] && { echo "$VHOSTS_DIR/$domain/vhost.conf"; return; }
  [[ -f "$VHOSTS_DIR/$domain/vhconf.conf" ]] && { echo "$VHOSTS_DIR/$domain/vhconf.conf"; return; }

  # Heuristic scan
  local f
  for f in "$VHOSTS_DIR"/*/vhost.conf "$VHOSTS_DIR"/*/vhconf.conf; do
    [[ -f "$f" ]] || continue
    perl -ne '
      BEGIN{ $d=lc($ENV{D}); $hit=0 }
      if (/^\s*vhDomain\s+(.*)$/i) {
        $_=lc($1); s/,/ /g;
        if (/\b\Q$d\E\b/) { $hit=1; print "hit\n"; exit 0 }
      }
    ' D="$domain" "$f" | grep -q '^hit$' && { echo "$f"; return; }
  done

  err "OpenLiteSpeed vhost for '$domain' not found under $VHOSTS_DIR.
Hints:
  • Create the site in CyberPanel first.
  • Or pass:  --vhconf /usr/local/lsws/conf/vhosts/<name>/(vhost|vhconf).conf"
}

docroot_from_vhconf(){
  local vhconf="$1"
  perl -ne '
    BEGIN{ $vhconf=$ENV{VH}; }
    if (/^\s*docRoot\s+(.*)$/){ $dr=$1; $dr =~ s/^"|"$//g; print "$dr\n"; exit 0 }
  ' VH="$vhconf" "$vhconf" | {
    read -r raw || true
    raw="${raw:-}"
    # expand variables
    local vhname vhroot
    vhname="$(basename "$(dirname "$vhconf")")"
    vhroot="$(perl -ne "if(/^\\s*vhRoot\\s+(.*)\$/){\$x=\$1; \$x=~s/^\\\"|\\\"\\\$//g; print \$x; exit}" "$vhconf" 2>/dev/null || true)"
    raw="${raw//\$SERVER_ROOT/$LSWS_ROOT}"
    raw="${raw//\$\{SERVER_ROOT\}/$LSWS_ROOT}"
    raw="${raw//\$VH_NAME/$vhname}"
    raw="${raw//\$\{VH_NAME\}/$vhname}"
    if [[ -n "$vhroot" ]]; then
      vhroot="${vhroot//\$SERVER_ROOT/$LSWS_ROOT}"
      vhroot="${vhroot//\$\{SERVER_ROOT\}/$LSWS_ROOT}"
      vhroot="${vhroot//\$VH_NAME/$vhname}"
      vhroot="${vhroot//\$\{VH_NAME\}/$vhname}"
      raw="${raw//\$VH_ROOT/$vhroot}"
      raw="${raw//\$\{VH_ROOT\}/$vhroot}"
    fi
    raw="$(echo "$raw" | sed -E 's@//+@/@g')"
    raw="${raw%/}"
    if [[ -z "$raw" || "$raw" == "/public_html" || "$raw" == "public_html" || "$raw" =~ [$][A-Z_\{] ]]; then
      raw="/home/$vhname/public_html"
    fi
    echo "$raw"
  }
}

workdir_for_domain(){
  local domain="$1" override="${2:-}" vh dr
  vh="$(vhconf_for "$domain" "$override")" || exit 1
  [[ -d "/home/$domain/public_html" ]] && { echo "/home/$domain/public_html"; return; }
  dr="$(docroot_from_vhconf "$vh" || true)"
  [[ -n "$dr" && -d "$dr" ]] && { echo "$dr"; return; }
  local guess
  guess="$(find /home -maxdepth 3 -type d -path "/home/*/public_html" 2>/dev/null | grep "/$domain/" -m1 || true)"
  [[ -n "$guess" ]] && { echo "$guess"; return; }
  err "Could not find document root for '$domain'. Ensure the website exists in CyberPanel."
}

# ------------ .NET / ports ------------
port_in_use(){
  local p="$1"
  ss -ltnH 2>/dev/null | awk -v P="$p" '{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$P" \
  || netstat -tln 2>/dev/null | awk -v P="$p" '$6=="LISTEN"{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$P"
}
alloc_port(){
  local domain="$1" p span=$((PORT_RANGE_END-PORT_RANGE_START+1))
  local seed=$(( $(printf '%s' "$domain" | cksum | awk '{print $1}') % span + PORT_RANGE_START ))
  for ((p=seed; p<=PORT_RANGE_END; p++)); do ! port_in_use "$p" && { echo "$p"; return; }; done
  for ((p=PORT_RANGE_START; p<seed; p++)); do ! port_in_use "$p" && { echo "$p"; return; }; done
  err "No free port in $PORT_RANGE_START..$PORT_RANGE_END"
}
get_port_from_service(){
  local domain="$1" envf svc p
  envf="$(envfile_path "$domain")"
  [[ -f "$envf" ]] && { p="$(awk -F= '/^PORT=/{print $2; exit}' "$envf" | tr -d ' \t\r')"; [[ -n "$p" ]] && { echo "$p"; return; }; }
  svc="$(service_path "$domain")"
  [[ -f "$svc" ]] && { p="$(sed -n 's/^Environment=PORT=\([0-9]\+\).*$/\1/p' "$svc" | tail -n1)"; [[ -n "$p" ]] && { echo "$p"; return; }; }
  p="$(systemctl show "$(service_name "$domain")" -p Environment 2>/dev/null | sed -n 's/^Environment=.*PORT=\([0-9]\+\).*$/\1/p' | head -n1)"
  [[ -n "$p" ]] && echo "$p" || return 1
}

resolve_dll_from_marker(){ [[ -f "$1/.dotnet" ]] && awk -F= '/^\s*DLL\s*=/ {print $2; exit}' "$1/.dotnet" | tr -d ' \t\r'; }
resolve_dll(){
  local dir="$1" dll="${2:-}" cand
  [[ -z "$dll" ]] && dll="$(resolve_dll_from_marker "$dir" || true)"
  [[ -z "$dll" ]] && err "--dll is required (or set DLL=YourApp.dll in $dir/.dotnet)"
  [[ "$dll" = /* && -f "$dll" ]] && { echo "$dll"; return; }
  for cand in "$dir/$dll" "$dir/publish/$dll" "$dir"/bin/*/*/publish/"$dll"; do [[ -f "$cand" ]] && { echo "$cand"; return; }; done
  cand="$(find "$dir" -maxdepth 2 -type f -name "$(basename "$dll")" -print -quit 2>/dev/null || true)"
  [[ -n "$cand" ]] && { echo "$cand"; return; }
  err "DLL '$dll' not found under '$dir'. Upload your published files."
}

# ------------ OLS editing (Perl, block-safe) ------------
ensure_virtualhost_enable(){
  local vhname="$1"
  local bkp="$HTTPD_CONF.bak.$(date +%s)"
  cp -a "$HTTPD_CONF" "$bkp"
  perl -0777 -i -pe '
    BEGIN { $vh = $ENV{VH}; $did=0 }
    s{
      (^ \s* virtualHost \s+ \Q$vh\E \s* \{)  (.*?)  (^ \s* \})
    }{
      my ($head,$body,$tail)=($1,$2,$3);
      if ($body !~ /^\s*enable\s+1\s*$/m) {
        if ($body =~ s/^\s*enable\s+\d+\s*$/  enable                 1/m) {
          # replaced existing enable
        } elsif ($body =~ s/^\s*configFile\b/  enable                 1\n$&/m) {
          # inserted before configFile
        } else {
          $body = "  enable                 1\n$body";
        }
        $did=1;
      }
      "$head$body$tail"
    }gmsx;
    END{ }
  ' VH="$vhname" "$HTTPD_CONF"
}

remove_root_contexts(){
  local vhconf="$1"
  perl -0777 -i -pe '
    # remove any root context blocks
    s/^\s*context\s*\/\s*\{(?:[^{}]|\{[^{}]*\})*^\s*\}\s*\n?//gms;
    # and our previous markers if any
    s/^# >>> cyberpanel-dotnet BEGIN.*?# <<< cyberpanel-dotnet END\s*\n?//gms;
    s/^# >>> cyberpanel-dotnet EXTAPP BEGIN.*?# <<< cyberpanel-dotnet END\s*\n?//gms;
  ' "$vhconf"
}

ensure_extapp_and_proxy(){
  local vhconf="$1" vhname="$2" port="$3"
  remove_root_contexts "$vhconf"
  local id; id="$(sanitize_id "$vhname")"
  cat >>"$vhconf" <<EOF
$MARK_EXT_BEGIN
extprocessor cpdotnet-$id {
  type                    proxy
  address                 127.0.0.1:$port
  maxConns                100
  pcKeepAliveTimeout      60
  initTimeout             60
  retryTimeout            0
  respBuffer              0
}
$MARK_EXT_END
$MARK_BEGIN
context / {
  type                    proxy
  proxyExtAppName         cpdotnet-$id
  addDefaultCharset       off
  cacheEnable             0
  rewrite                 0
}
# Keep ACME static for SSL renewals
context /.well-known/acme-challenge/ {
  location                \$DOC_ROOT/.well-known/acme-challenge/
  allowBrowse             1
}
$MARK_END
EOF
}

fix_listener_mappings(){
  local domain="$1" vhname="$2"
  local bkp="$HTTPD_CONF.bak.$(date +%s)"
  cp -a "$HTTPD_CONF" "$bkp"
  perl -0777 -i -pe '
    BEGIN{ $vh=$ENV{VH}; $d=$ENV{D}; $dw="www.$ENV{D}"; }
    # Inside each listener block, rebuild map list with our map first and drop dups for the domain.
    s{
      (^ \s* listener \b [^{]* \{) (.*?) (^ \s* \})
    }{
      my ($head,$body,$tail)=($1,$2,$3);
      my @out = ("  map  $vh  $d $dw\n");
      my @keep;
      for my $line (split /\n/, $body){
        if ($line =~ /^\s*map\b/i){
          my $lc = lc($line);
          next if $lc =~ /\b\Q$d\E\b/;      # drop any existing for domain
          next if $lc =~ /\b\Q$dw\E\b/;
          push @keep, "$line\n";
        } else {
          push @keep, "$line\n" unless $line =~ /^\s*$/;
        }
      }
      $head . (join("", @out, @keep)) . $tail
    }gmsx;
  ' VH="$vhname" D="$domain" "$HTTPD_CONF"
}

# ------------ Commands ------------
cmd_check(){
  need perl; need sed; need grep; ols_paths
  local domain="$1" vhconf docroot p
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  docroot="$(docroot_from_vhconf "$vhconf" || true)"; [[ -z "$docroot" ]] && docroot="/home/$domain/public_html"
  echo "LSWS_ROOT=$LSWS_ROOT"
  echo "CONF_DIR=$CONF_DIR"
  echo "VHOSTS_DIR=$VHOSTS_DIR"
  echo "HTTPD_CONF=$HTTPD_CONF"
  echo "VHCONF=$vhconf"
  echo "DOCROOT=$docroot"
  p="$(get_port_from_service "$domain" || true)"
  echo "PORT=${p:-'(not assigned yet)'}"
}

cmd_port(){ ols_paths; get_port_from_service "$1"; }

cmd_logs(){
  local domain="$1"; shift || true
  local lines=200 follow=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --lines|-n) lines="$2"; shift 2;;
      -f|--follow) follow=1; shift;;
      *) break;;
    esac
  done
  [[ "$follow" -eq 1 ]] && journalctl -u "$(service_name "$domain")" -f || journalctl -u "$(service_name "$domain")" -n "$lines"
}

cmd_redeploy(){
  if [[ $# -eq 0 ]]; then
    systemctl list-units 'dotnet-app@*.service' --no-legend | awk '{print $1}' | while read -r u; do systemctl restart "$u" || true; done
    echo "Redeployed all"
  else
    systemctl restart "$(service_name "$1")"; echo "Redeployed $1"
  fi
}

cmd_disable(){
  ols_paths
  local domain="$1" vhconf
  systemctl stop "$(service_name "$domain")" || true
  systemctl disable "$(service_name "$domain")" || true
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  remove_root_contexts "$vhconf" || true
  ols_reload
  echo "Disabled $domain"
}

cmd_enable(){
  need perl; need sed; need grep; ols_paths

  local domain="" dll="" port="" override_vh=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dll) dll="$2"; shift 2;;
      --port) port="$2"; shift 2;;
      --vhconf) override_vh="$2"; shift 2;;
      --help|-h) echo "Usage: cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N] [--vhconf /path/to/(vhost|vhconf).conf]"; return 0;;
      *) domain="$1"; shift;;
    esac
  done
  [[ -n "$domain" ]] || err "Usage: enable <domain> --dll YourApp.dll"

  local vhconf docroot dll_path user uid envf unit vhname_map conf_map also=""
  vhconf="$(vhconf_for "$domain" "$override_vh")"
  docroot="$(workdir_for_domain "$domain" "$vhconf")"
  dll_path="$(resolve_dll "$docroot" "$dll")"

  uid="$(stat -c '%u' "$docroot" 2>/dev/null || echo 0)"
  user="$(getent passwd "$uid" | cut -d: -f1 || true)"; [[ -z "$user" ]] && user="www-data"

  if [[ -z "${port:-}" ]]; then port="$(get_port_from_service "$domain" || true)"; [[ -z "$port" ]] && port="$(alloc_port "$domain")"; fi

  envf="$(envfile_path "$domain")"
  cat >"$envf" <<EOF
DOMAIN=$domain
DOCROOT=$docroot
PORT=$port
USER=$user
DLL_PATH=$dll_path
EOF
  chmod 0644 "$envf"

  unit="$(service_name "$domain")"
  systemctl daemon-reload || true
  systemctl enable "$unit" >/dev/null 2>&1 || true
  systemctl restart "$unit"

  # Get mapped virtualHost and its config file
  vhname_map="$(virt_name_for_domain "$domain" || true)"
  [[ -z "$vhname_map" ]] && vhname_map="$(basename "$(dirname "$vhconf")")"
  conf_map="$(configfile_for_vh_name "$vhname_map" || true)"

  # Ensure the mapped virtualHost is enabled
  ensure_virtualhost_enable "$vhname_map"

  # Inject proxy/extapp into the resolved file (always)
  ensure_extapp_and_proxy "$vhconf" "$vhname_map" "$port"

  # If httpd_config maps to a different file, inject there too
  if [[ -n "$conf_map" && -f "$conf_map" && "$conf_map" != "$vhconf" ]]; then
    ensure_extapp_and_proxy "$conf_map" "$vhname_map" "$port"
    also="$conf_map"
  fi

  # Fix listener maps to point to this virtualHost, dedupe
  fix_listener_mappings "$domain" "$vhname_map"
  ols_reload

  grn "✅ Enabled $domain"
  echo "------------------------------------------------------------"
  echo "Public URL:    http(s)://$domain"
  echo "Reverse proxy: ADDED in $vhconf (OpenLiteSpeed)"
  [[ -n "$also" ]] && echo "Also touched:   $also (mapped by httpd_config.conf)"
  echo "Internal URL:  http://127.0.0.1:$port  (Kestrel)"
  echo "Systemd unit:  $(service_name "$domain")"
  echo "Env file:      $(envfile_path "$domain")"
  echo
  echo "Next steps:"
  echo " • Open your site:   https://$domain   (if SSL is configured in CyberPanel)"
  echo " • Live logs:        journalctl -u $(service_name "$domain") -f"
  echo " • Redeploy now:     sudo cyberpanel-dotnet redeploy $domain"
  echo " • Check detected:   sudo cyberpanel-dotnet check $domain"
  echo "------------------------------------------------------------"
}

cmd_fixmap(){
  need perl; ols_paths
  local domain="$1" vhconf vhname
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  vhname="$(virt_name_for_domain "$domain" || true)"
  [[ -z "$vhname" ]] && vhname="$(basename "$(dirname "$vhconf")")"
  ensure_virtualhost_enable "$vhname"
  fix_listener_mappings "$domain" "$vhname"
}

usage(){
  cat <<EOF
cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel

Usage:
  cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N] [--vhconf /path/to/(vhost|vhconf).conf]
  cyberpanel-dotnet disable <domain>
  cyberpanel-dotnet redeploy [<domain>]
  cyberpanel-dotnet port <domain>
  cyberpanel-dotnet logs <domain> [--lines N|-n N] [-f]
  cyberpanel-dotnet check <domain>
  cyberpanel-dotnet fixmap <domain>
EOF
}

main(){
  [[ $# -ge 1 ]] || { usage; exit 1; }
  local cmd="$1"; shift || true
  case "$cmd" in
    enable)   cmd_enable "$@";;
    disable)  [[ $# -ge 1 ]] || err "Usage: disable <domain>"; cmd_disable "$@";;
    redeploy) cmd_redeploy "$@";;
    port)     [[ $# -ge 1 ]] || err "Usage: port <domain>"; cmd_port "$@";;
    logs)     [[ $# -ge 1 ]] || err "Usage: logs <domain> [--lines N|-n N] [-f]"; cmd_logs "$@";;
    check)    [[ $# -ge 1 ]] || err "Usage: check <domain>"; cmd_check "$@";;
    fixmap)   [[ $# -ge 1 ]] || err "Usage: fixmap <domain>"; cmd_fixmap "$@";;
    -h|--help|help) usage;;
    *) err "Unknown command: $cmd";;
  esac
}
main "$@"
