#!/usr/bin/env bash
# cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel (OpenLiteSpeed)
# Author: Mohd Khalid — MIT
set -Eeuo pipefail
shopt -s extglob nullglob

# ---------- UI helpers ----------
red(){ echo -e "\e[31m$*\e[0m"; }
grn(){ echo -e "\e[32m$*\e[0m"; }
yel(){ echo -e "\e[33m$*\e[0m"; }
err(){ red "[ERROR] $*" 1>&2; exit 1; }
info(){ echo "[i] $*"; }
need(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1"; }

# ---------- Globals ----------
SYSTEMD_DIR="/etc/systemd/system"
ENV_DIR="/etc/dotnet-apps"
STATE_DIR="/etc/cyberpanel-dotnet"
PORT_RANGE_START=${PORT_RANGE_START:-5100}
PORT_RANGE_END=${PORT_RANGE_END:-8999}

MARK_BEGIN="# >>> cyberpanel-dotnet BEGIN"
MARK_END="# <<< cyberpanel-dotnet END"
MARK_EXT_BEGIN="# >>> cyberpanel-dotnet EXTAPP BEGIN"
MARK_EXT_END="# <<< cyberpanel-dotnet EXTAPP END"

LSWS_ROOT=""
CONF_DIR=""
HTTPD_CONF=""
VHOSTS_DIR=""

mkdir -p "$STATE_DIR" "$ENV_DIR"

# ---------- ID helpers ----------
sanitize_id(){
  echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g; s/[.]/_/g'
}
service_name(){ local id; id=$(sanitize_id "$1"); echo "dotnet-app@${id}.service"; }
service_path(){ echo "$SYSTEMD_DIR/$(service_name "$1")"; }
envfile_path(){ local id; id=$(sanitize_id "$1"); echo "$ENV_DIR/${id}.env"; }

# ---------- OLS discovery ----------
_detect_lsws_root(){
  if [[ -n "${LSWS_ROOT:-}" && -x "${LSWS_ROOT}/bin/lswsctrl" ]]; then echo "$LSWS_ROOT"; return; fi
  if [[ -x "/usr/local/lsws/bin/lswsctrl" ]]; then echo "/usr/local/lsws"; return; fi
  if command -v lswsctrl >/dev/null 2>&1; then
    local p; p="$(command -v lswsctrl)"; p="$(readlink -f "$p" 2>/dev/null || echo "$p")"
    echo "${p%/bin/lswsctrl}"; return
  fi
  [[ -d "/usr/local/lsws" ]] && { echo "/usr/local/lsws"; return; }
  return 1
}
ols_paths(){
  LSWS_ROOT="$(_detect_lsws_root)" || err "OpenLiteSpeed not found"
  CONF_DIR="$LSWS_ROOT/conf"
  HTTPD_CONF="$CONF_DIR/httpd_config.conf"
  VHOSTS_DIR="$CONF_DIR/vhosts"
  [[ -f "$HTTPD_CONF" && -d "$VHOSTS_DIR" ]] || err "OLS conf missing under $CONF_DIR"
}
ols_reload(){
  if [[ -x "$LSWS_ROOT/bin/lswsctrl" ]]; then "$LSWS_ROOT/bin/lswsctrl" reload || true; fi
  systemctl reload lsws 2>/dev/null || systemctl restart lsws 2>/dev/null || true
}
trim_slash(){ local p="${1:-}"; p="${p%/}"; echo "$p"; }

# ---------- vhost helpers ----------
_expand_vars(){
  local raw="${1:-}" vhconf="${2:-}"
  local vhname serverroot="$LSWS_ROOT" vhroot=""
  vhname="$(basename "$(dirname "$vhconf")")"
  vhroot="$(awk '/^[ \t]*vhRoot[ \t]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  vhroot="${vhroot%\"}"; vhroot="${vhroot#\"}"
  if [[ -n "$vhroot" ]]; then
    vhroot="${vhroot//\$SERVER_ROOT/$serverroot}"
    vhroot="${vhroot//\$\{SERVER_ROOT\}/$serverroot}"
    vhroot="${vhroot//\$VH_NAME/$vhname}"
    vhroot="${vhroot//\$\{VH_NAME\}/$vhname}"
  fi
  raw="${raw//\$VH_ROOT/$vhroot}"
  raw="${raw//\$\{VH_ROOT\}/$vhroot}"
  raw="${raw//\$SERVER_ROOT/$serverroot}"
  raw="${raw//\$\{SERVER_ROOT\}/$serverroot}"
  raw="${raw//\$VH_NAME/$vhname}"
  raw="${raw//\$\{VH_NAME\}/$vhname}"
  echo "$raw"
}
docroot_from_vhconf(){
  local vhconf="$1"
  local raw dr
  raw="$(awk '/^[ \t]*docRoot[ \t]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  raw="${raw%\"}"; raw="${raw#\"}"
  dr="$(_expand_vars "$raw" "$vhconf")"
  dr="$(echo "$dr" | sed -E 's@//+@/@g')"
  dr="${dr%/}"
  # if still wrong or contains leftover $VARS, fallback to canonical path
  if [[ -z "$dr" || "$dr" == "/public_html" || "$dr" == "public_html" || "$dr" =~ [$][A-Z_\{] ]]; then
    local vhname dguess
    vhname="$(basename "$(dirname "$vhconf")")"
    dguess="$(awk '
      /^[[:space:]]*vhDomain[[:space:]]+/{
        for(i=2;i<=NF;i++){ gsub(/,|"/,"",$i); if($i!=""){ print $i; exit } }
      }' "$vhconf" 2>/dev/null || true)"
    [[ -z "$dguess" ]] && dguess="$vhname"
    dr="/home/$dguess/public_html"
  fi
  echo "$dr"
}
_vhname_from_map(){
  local domain="$1"
  awk -v D="$domain" '
    BEGIN{in=0}
    /^[[:space:]]*listener[[:space:]]+/ { in=1; next }
    in==1 && /^[[:space:]]*map[[:space:]]+/ {
      line = tolower($0); d = tolower(D);
      if (index(line, d)) { print $2; exit }
      next
    }
    in==1 && /^[[:space:]]*}/ { in=0 }
  ' "$HTTPD_CONF" 2>/dev/null || true
}
_configfile_for_vh(){
  local vhname="$1"
  local raw
  raw="$(awk -v N="$vhname" '
    BEGIN{in=0}
    /^[[:space:]]*virtualHost[[:space:]]+/ { in = ($2==N); next }
    in==1 && /^[[:space:]]*configFile[[:space:]]+/ { print $2; exit }
    in==1 && /^[[:space:]]*}/ { in=0 }
  ' "$HTTPD_CONF" 2>/dev/null || true)"
  [[ -z "$raw" ]] && return 1
  local exp="${raw//\$SERVER_ROOT/$LSWS_ROOT}"
  exp="${exp//\$VH_NAME/$vhname}"
  if [[ "${exp:0:1}" != "/" ]]; then exp="$LSWS_ROOT/$exp"; fi
  echo "$exp"
}
vhconf_for(){
  local domain="$1" override="${2:-}"
  [[ -n "$override" && -f "$override" ]] && { echo "$override"; return; }

  local vhname conf
  vhname="$(_vhname_from_map "$domain")"
  if [[ -n "$vhname" ]]; then
    conf="$(_configfile_for_vh "$vhname" || true)"
    [[ -n "$conf" && -f "$conf" ]] && { echo "$conf"; return; }
    [[ -f "$VHOSTS_DIR/$vhname/vhost.conf"   ]] && { echo "$VHOSTS_DIR/$vhname/vhost.conf"; return; }
    [[ -f "$VHOSTS_DIR/$vhname/vhconf.conf"  ]] && { echo "$VHOSTS_DIR/$vhname/vhconf.conf"; return; }
  fi

  [[ -f "$VHOSTS_DIR/$domain/vhost.conf"  ]] && { echo "$VHOSTS_DIR/$domain/vhost.conf"; return; }
  [[ -f "$VHOSTS_DIR/$domain/vhconf.conf" ]] && { echo "$VHOSTS_DIR/$domain/vhconf.conf"; return; }

  local f dr
  for f in "$VHOSTS_DIR"/*/vhost.conf "$VHOSTS_DIR"/*/vhconf.conf; do
    [[ -f "$f" ]] || continue
    if dr="$(docroot_from_vhconf "$f" || true)"; then
      [[ "$(trim_slash "$dr")" == "/home/$domain/public_html" ]] && { echo "$f"; return; }
      echo "$dr" | grep -qiE "/$domain(/|.*)public_html/?$" && { echo "$f"; return; }
    fi
  done

  err "OpenLiteSpeed vhost for '$domain' not found under $VHOSTS_DIR.
Hints:
  • Ensure the site exists in CyberPanel.
  • Or pass:  --vhconf /usr/local/lsws/conf/vhosts/<name>/(vhost|vhconf).conf"
}
workdir_for_domain(){
  local domain="$1" override="${2:-}" vh dr
  vh="$(vhconf_for "$domain" "$override")" || exit 1

  # canonical CyberPanel path first
  if [[ -d "/home/$domain/public_html" ]]; then echo "/home/$domain/public_html"; return; fi

  dr="$(docroot_from_vhconf "$vh" || true)"
  if [[ -n "$dr" && -d "$dr" ]]; then echo "$dr"; return; fi

  local guess
  guess="$(find /home -maxdepth 3 -type d -path "/home/*/public_html" 2>/dev/null | grep "/$domain/" -m1 || true)"
  [[ -n "$guess" ]] && { echo "$guess"; return; }

  err "Could not find document root for '$domain'. Ensure the website exists in CyberPanel."
}

# ---------- .NET + ports ----------
find_dotnet(){ command -v dotnet >/dev/null 2>&1 && command -v dotnet || return 1; }
port_in_use(){ ss -ltnH 2>/dev/null | awk '{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$1"; }
alloc_port(){
  local domain="$1" seed p
  seed=$(( ( $(echo -n "$domain" | md5sum | cut -c1-6 | tr 'a-f' '1-6') % 2000 ) + PORT_RANGE_START ))
  for ((p=seed; p<=PORT_RANGE_END; p++)); do
    if ! port_in_use "$p"; then echo "$p"; return; fi
  done
  err "No free port in $PORT_RANGE_START..$PORT_RANGE_END"
}
get_port_from_service(){
  local domain="$1" envf svc_path p
  envf="$(envfile_path "$domain")"
  if [[ -f "$envf" ]]; then
    p="$(awk -F= '/^PORT=/{print $2; exit}' "$envf" | tr -d ' \t\r')"
    [[ -n "$p" ]] && { echo "$p"; return; }
  fi
  svc_path="$(service_path "$domain")"
  if [[ -f "$svc_path" ]]; then
    p="$(sed -n 's/^Environment=PORT=\([0-9]\+\).*$/\1/p' "$svc_path" | tail -n1)"
    [[ -n "$p" ]] && { echo "$p"; return; }
    p="$(sed -n 's/^Environment=ASPNETCORE_URLS=.*:\([0-9]\+\).*$/\1/p' "$svc_path" | tail -n1)"
    [[ -n "$p" ]] && { echo "$p"; return; }
  fi
  p="$(systemctl show "$(service_name "$domain")" -p Environment 2>/dev/null | sed -n 's/^Environment=.*PORT=\([0-9]\+\).*$/\1/p' | head -n1)"
  [[ -n "$p" ]] && echo "$p" || return 1
}

resolve_dll_from_marker(){
  local workdir="$1"
  if [[ -f "$workdir/.dotnet" ]]; then
    local dll
    dll="$(awk -F= '/^\s*DLL\s*=/{print $2; exit}' "$workdir/.dotnet" | tr -d ' \t\r')"
    [[ -n "$dll" ]] && { echo "$dll"; return; }
  fi
  return 1
}
resolve_dll(){
  local workdir="$1"; local dll="${2:-}"
  if [[ -z "$dll" ]]; then
    if dll="$(resolve_dll_from_marker "$workdir")"; then :; else err "--dll is required (or set DLL=YourApp.dll in $workdir/.dotnet)"; fi
  fi
  if [[ "$dll" = /* && -f "$dll" ]]; then echo "$dll"; return; fi
  local cand
  for cand in \
    "$workdir/$dll" \
    "$workdir/publish/$dll" \
    "$workdir"/bin/*/*/publish/"$dll"
  do
    [[ -f "$cand" ]] && { echo "$cand"; return; }
  done
  cand="$(find "$workdir" -maxdepth 2 -type f -name "$(basename "$dll")" -print -quit 2>/dev/null || true)"
  [[ -n "$cand" ]] && { echo "$cand"; return; }
  err "DLL '$dll' not found under '$workdir'. Upload your published files."
}

# ---------- OLS file editing ----------
remove_root_contexts(){
  local vhconf="$1"
  awk '
    BEGIN{depth=0; inroot=0}
    /^[ \t]*context[ \t]*\/[ \t]*\{/ { inroot=1; depth=1; next }
    inroot==1 {
      for(i=1;i<=length($0);i++){
        c=substr($0,i,1)
        if(c=="{")depth++
        else if(c=="}"){ depth--; if(depth==0){ inroot=0; next } }
      }
      next
    }
    { print }
  ' "$vhconf" > "$vhconf.__no_root__"
  mv "$vhconf.__no_root__" "$vhconf"
}
drop_extprocessor(){
  local vhconf="$1" name="$2"
  awk -v NAME="$name" '
    BEGIN{drop=0; depth=0}
    /^[ \t]*extprocessor[ \t]+/ && $2==NAME {
      drop=1; depth=0
      for(i=1;i<=length($0);i++){ c=substr($0,i,1); if(c=="{")depth++; else if(c=="}")depth--; }
      next
    }
    drop==1 {
      for(i=1;i<=length($0);i++){
        c=substr($0,i,1)
        if(c=="{") depth++
        else if(c=="}"){ depth--; if(depth<=0){ drop=0; break } }
      }
      if(drop==1) next
    }
    { print }
  ' "$vhconf" > "$vhconf.__no_ext__"
  mv "$vhconf.__no_ext__" "$vhconf"
}
ensure_vhDomain(){
  local vhconf="$1" domain="$2"
  if grep -qiE '^[[:space:]]*vhDomain[[:space:]]+' "$vhconf"; then
    local cur rest merged
    cur="$(grep -iE '^[[:space:]]*vhDomain[[:space:]]+' "$vhconf" | head -n1)"
    rest="${cur#*vhDomain}"; rest="$(echo "$rest" | tr -d '\r' | tr ',' ' ' | tr '[:upper:]' '[:lower:]')"
    merged="$(printf '%s\n%s\nwww.%s\n' "$rest" "$domain" "$domain" | tr ' ' '\n' | sed '/^$/d' | sort -u | paste -sd',' -)"
    awk -v NEW="vhDomain $merged" '
      BEGIN{done=0}
      { if (!done && $0 ~ /^[[:space:]]*vhDomain[[:space:]]+/) { print NEW; done=1 } else print $0 }
    ' "$vhconf" > "$vhconf.__vhd__" && mv "$vhconf.__vhd__" "$vhconf"
  else
    printf '\n# added by cyberpanel-dotnet\nvhDomain %s, %s\n' "$domain" "www.$domain" >> "$vhconf"
  fi
}
ensure_vhost_enabled(){
  local vhname="$1"
  local tmp; tmp="$(mktemp)"
  awk -v N="$vhname" '
    BEGIN{in=0}
    /^[[:space:]]*virtualHost[[:space:]]+/ { in = ($2==N); print; next }
    in==1 && /^[[:space:]]*enable[[:space:]]+0/ { sub(/enable[[:space:]]+0/, "enable                 1"); print; next }
    in==1 && /^[[:space:]]*enable[[:space:]]+1/ { print; next }
    in==1 && /^[[:space:]]*configFile[[:space:]]+/ { print; next }
    in==1 && /^[[:space:]]*}/ { print; in=0; next }
    { print }
  ' "$HTTPD_CONF" > "$tmp" && mv "$tmp" "$HTTPD_CONF"
}
ensure_extproxy_and_root(){
  local vhconf="$1" vhname="$2" port="$3"
  local ep="cpdotnet-$(echo "$vhname" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g')"
  drop_extprocessor "$vhconf" "$ep"
  remove_root_contexts "$vhconf"
  sed -i '/^# >>> cyberpanel-dotnet BEGIN/,/^# <<< cyberpanel-dotnet END/d' "$vhconf" || true
  sed -i '/^# >>> cyberpanel-dotnet EXTAPP BEGIN/,/^# <<< cyberpanel-dotnet EXTAPP END/d' "$vhconf" || true
  cat >>"$vhconf" <<EOF
$MARK_EXT_BEGIN
extprocessor $ep {
  type                    proxy
  address                 127.0.0.1:$port
  maxConns                200
  pcKeepAliveTimeout      60
  initTimeout             60
  retryTimeout            0
  respBuffer              0
}
# Keep ACME static for SSL renewals
context /.well-known/acme-challenge/ {
  location                \$DOC_ROOT/.well-known/acme-challenge/
  allowBrowse             1
}
$MARK_EXT_END

$MARK_BEGIN
context / {
  type                    proxy
  proxyExtAppName         $ep
  addDefaultCharset       off
  cacheEnable             0
  rewrite                 0
}
$MARK_END
EOF
}
fix_listener_mappings(){
  local domain="$1" vhname="$2"
  local httpd="$HTTPD_CONF"
  [[ -f "$httpd" ]] || err "httpd_config.conf not found"
  cp -a "$httpd" "$httpd.bak.$(date +%s)"
  awk -v VH="$vhname" -v D1="$domain" -v D2="www.$domain" '
    BEGIN { blk=0 }
    {
      line=$0
      if (line ~ /^[ \t]*listener[ \t]+/) { blk=1; print line; next }
      if (blk==1 && line ~ /^[ \t]*address[ \t]+/) { print line; next }
      if (blk==1 && line ~ /^[ \t]*secure[ \t]+/)  { print line; next }
      if (blk==1 && line ~ /^[ \t]*map[ \t]+/) {
        low = tolower(line)
        if (index(low, tolower(D1))>0 || index(low, tolower(D2))>0) { next }
        print line; next
      }
      if (blk==1 && line ~ /^[ \t]*}/) {
        print "  map  " VH "  " D1 " " D2
        blk=0; print line; next
      }
      print line
    }
  ' "$httpd" > "$httpd.__new__"
  mv "$httpd.__new__" "$httpd"
  ols_reload
}

# ---------- Commands ----------
cmd_check(){
  need awk; need sed; need grep; ols_paths
  local domain="$1" vhconf docroot p
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  docroot="$(docroot_from_vhconf "$vhconf" || true)"
  [[ -z "$docroot" ]] && docroot="/home/$domain/public_html"
  echo "LSWS_ROOT=$LSWS_ROOT"
  echo "CONF_DIR=$CONF_DIR"
  echo "VHOSTS_DIR=$VHOSTS_DIR"
  echo "HTTPD_CONF=$HTTPD_CONF"
  echo "VHCONF=$vhconf"
  echo "DOCROOT=$docroot"
  p="$(get_port_from_service "$domain" || true)"
  echo "PORT=${p:-'(not assigned yet)'}"
}
cmd_port(){ ols_paths; get_port_from_service "$1"; }
cmd_logs(){
  local domain="$1"; shift || true
  local lines=200 follow=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --lines|-n) lines="$2"; shift 2;;
      -f|--follow) follow=1; shift;;
      *) break;;
    esac
  done
  if [[ "$follow" -eq 1 ]]; then
    journalctl -u "$(service_name "$domain")" -f
  else
    journalctl -u "$(service_name "$domain")" -n "$lines"
  fi
}
cmd_redeploy(){
  if [[ $# -eq 0 ]]; then
    systemctl list-units 'dotnet-app@*.service' --no-legend | awk '{print $1}' | while read -r u; do systemctl restart "$u" || true; done
    echo "Redeployed all"
  else
    systemctl restart "$(service_name "$1")"
    echo "Redeployed $1"
  fi
}
cmd_disable(){
  ols_paths
  local domain="$1" vhconf
  systemctl stop "$(service_name "$domain")" || true
  systemctl disable "$(service_name "$domain")" || true
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  sed -i '/^# >>> cyberpanel-dotnet BEGIN/,/^# <<< cyberpanel-dotnet END/d' "$vhconf" || true
  sed -i '/^# >>> cyberpanel-dotnet EXTAPP BEGIN/,/^# <<< cyberpanel-dotnet EXTAPP END/d' "$vhconf" || true
  remove_root_contexts "$vhconf" || true
  ols_reload
  echo "Disabled $domain"
}
cmd_enable(){
  need awk; need sed; need grep; ols_paths
  local domain="" dll="" port="" override_vh=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dll) dll="$2"; shift 2;;
      --port) port="$2"; shift 2;;
      --vhconf) override_vh="$2"; shift 2;;
      --help|-h) echo "Usage: cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N] [--vhconf /path/to/(vhost|vhconf).conf]"; return 0;;
      *) domain="$1"; shift;;
    esac
  done
  [[ -n "$domain" ]] || err "Usage: enable <domain> --dll YourApp.dll"

  local vhconf docroot dll_path user uid vhname envf unit
  vhconf="$(vhconf_for "$domain" "$override_vh")"
  docroot="$(workdir_for_domain "$domain" "$vhconf")"
  dll_path="$(resolve_dll "$docroot" "$dll")"

  uid="$(stat -c '%u' "$docroot" 2>/dev/null || echo 0)"
  user="$(getent passwd "$uid" | cut -d: -f1 || true)"
  [[ -n "$user" ]] || user="www-data"

  if [[ -z "${port:-}" ]]; then
    port="$(get_port_from_service "$domain" || true)"
    [[ -z "$port" ]] && port="$(alloc_port "$domain")"
  fi

  envf="$(envfile_path "$domain")"
  cat >"$envf" <<EOF
DOMAIN=$domain
DOCROOT=$docroot
PORT=$port
USER=$user
DLL_PATH=$dll_path
EOF
  chmod 0644 "$envf"

  unit="$(service_name "$domain")"
  systemctl daemon-reload || true
  systemctl enable "$unit" >/dev/null 2>&1 || true
  systemctl restart "$unit"

  vhname="$(basename "$(dirname "$vhconf")")"
  ensure_vhost_enabled "$vhname"
  ensure_vhDomain "$vhconf" "$domain"
  ensure_extproxy_and_root "$vhconf" "$vhname" "$port"
  fix_listener_mappings "$domain" "$vhname"
  ols_reload

  grn "✅ Enabled $domain"
  echo "------------------------------------------------------------"
  echo "Public URL:    http(s)://$domain"
  echo "Reverse proxy: ADDED in $vhconf (OpenLiteSpeed) [cyberpanel-dotnet markers]"
  echo "Internal URL:  http://127.0.0.1:$port  (Kestrel)"
  echo "Systemd unit:  $(service_name "$domain")"
  echo "Env file:      $(envfile_path "$domain")"
  echo
  echo "Next steps:"
  echo " • Open your site:   https://$domain   (if SSL is configured in CyberPanel)"
  echo " • Live logs:        journalctl -u $(service_name "$domain") -f"
  echo " • Redeploy now:     sudo cyberpanel-dotnet redeploy $domain"
  echo " • Check detected:   sudo cyberpanel-dotnet check $domain"
  echo "------------------------------------------------------------"
}
cmd_fixmap(){
  ols_paths
  local domain="$1" vhconf vhname
  vhconf="$(vhconf_for "$domain" "${VHCONF_OVERRIDE:-}")"
  vhname="$(basename "$(dirname "$vhconf")")"
  fix_listener_mappings "$domain" "$vhname"
}

# ---------- CLI ----------
usage(){
  cat <<EOF
cyberpanel-dotnet — make ASP.NET Core deploy like PHP on CyberPanel

Usage:
  cyberpanel-dotnet enable <domain> --dll YourApp.dll [--port N] [--vhconf /path/to/(vhost|vhconf).conf]
  cyberpanel-dotnet disable <domain>
  cyberpanel-dotnet redeploy [<domain>]
  cyberpanel-dotnet port <domain>
  cyberpanel-dotnet logs <domain> [--lines N|-n N] [-f]
  cyberpanel-dotnet check <domain>
  cyberpanel-dotnet fixmap <domain>
EOF
}
main(){
  [[ $# -ge 1 ]] || { usage; exit 1; }
  local cmd="$1"; shift || true
  case "$cmd" in
    enable)   cmd_enable "$@";;
    disable)  [[ $# -ge 1 ]] || err "Usage: disable <domain>"; cmd_disable "$@";;
    redeploy) cmd_redeploy "$@";;
    port)     [[ $# -ge 1 ]] || err "Usage: port <domain>"; cmd_port "$@";;
    logs)     [[ $# -ge 1 ]] || err "Usage: logs <domain> [--lines N|-n N] [-f]"; cmd_logs "$@";;
    check)    [[ $# -ge 1 ]] || err "Usage: check <domain>"; cmd_check "$@";;
    fixmap)   [[ $# -ge 1 ]] || err "Usage: fixmap <domain>"; cmd_fixmap "$@";;
    -h|--help|help) usage;;
    *) err "Unknown command: $cmd";;
  esac
}
main "$@"
