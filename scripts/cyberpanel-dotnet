#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s extglob

# ---------- UI helpers ----------
red(){ echo -e "\e[31m$*\e[0m"; }
grn(){ echo -e "\e[32m$*\e[0m"; }
yel(){ echo -e "\e[33m$*\e[0m"; }
err(){ red "[ERROR] $*" 1>&2; exit 1; }
info(){ echo "[i] $*"; }
sudo_ok(){ [[ ${EUID:-$(id -u)} -eq 0 ]] || err "Run as root (sudo)."; }
need(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1 (please install it)"; }

# ---------- Globals ----------
SYSTEMD_DIR="/etc/systemd/system"
ENV_DIR="/etc/dotnet-apps"
STATE_DIR="/etc/cyberpanel-dotnet"
PORT_RANGE_START=${PORT_RANGE_START:-5100}
PORT_RANGE_END=${PORT_RANGE_END:-8999}
MARK_BEGIN="# >>> cyberpanel-dotnet BEGIN"
MARK_END="# <<< cyberpanel-dotnet END"

LSWS_ROOT=""
VHOSTS_DIR=""
CONF_DIR=""

mkdir -p "$STATE_DIR" "$ENV_DIR"

# ---------- ID helpers ----------
sanitize_id(){ echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g; s/[.]/_/g'; }
service_name(){ local id; id=$(sanitize_id "$1"); echo "dotnet-app@${id}.service"; }
service_path(){ echo "$SYSTEMD_DIR/$(service_name "$1")"; }
envfile_path(){ local id; id=$(sanitize_id "$1"); echo "$ENV_DIR/${id}.env"; }

# ---------- OpenLiteSpeed discovery ----------
_detect_lsws_root(){
  if [[ -n "${LSWS_ROOT:-}" && -x "${LSWS_ROOT}/bin/lswsctrl" ]]; then echo "$LSWS_ROOT"; return; fi
  if [[ -x "/usr/local/lsws/bin/lswsctrl" ]]; then echo "/usr/local/lsws"; return; fi
  if command -v lswsctrl >/dev/null 2>&1; then
    local p; p=$(command -v lswsctrl)
    p=$(readlink -f "$p" 2>/dev/null || echo "$p")
    echo "${p%/bin/lswsctrl}"; return
  fi
  if [[ -d "/usr/local/lsws" ]]; then echo "/usr/local/lsws"; return; fi
  return 1
}

trim_slash(){ local p="${1:-}"; p="${p%/}"; echo "$p"; }

# Expand $VH_ROOT/$SERVER_ROOT/$VH_NAME inside a vhost conf
_expand_vars(){
  local raw="${1:-}" vhconf="${2:-}"
  local vhroot="" vhname="" serverroot="$LSWS_ROOT"
  vhname="$(basename "$(dirname "$vhconf")")"
  vhroot="$(awk '/^[[:space:]]*vhRoot[[:space:]]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  vhroot="${vhroot%\"}"; vhroot="${vhroot#\"}"
  raw="${raw//\$VH_ROOT/$vhroot}"
  raw="${raw//\$SERVER_ROOT/$serverroot}"
  raw="${raw//\$VH_NAME/$vhname}"
  echo "$raw"
}

# Resolve docRoot from a vhconf, expanding variables
docroot_from_vhconf(){
  local vhconf="$1"
  local dr; dr="$(awk '/^[[:space:]]*docRoot[[:space:]]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  dr="${dr%\"}"; dr="${dr#\"}"
  [[ -z "$dr" ]] && return 1
  dr="$(_expand_vars "$dr" "$vhconf")"
  dr="${dr%\"}"; dr="${dr#\"}"
  dr="$(trim_slash "$dr")"
  [[ -n "$dr" ]] && echo "$dr" && return 0
  return 1
}

# Parse listener "map" lines anywhere in $CONF_DIR to resolve domain -> vhost name
_vhname_from_map(){
  local domain="$1"
  local f line name
  shopt -s nullglob
  while IFS= read -r -d '' f; do
    while IFS= read -r line; do
      echo "$line" | grep -qi -- "$domain" || continue
      name=$(awk 'BEGIN{IGNORECASE=1}
        /^[[:space:]]*map[[:space:]]+/ {
          for(i=1;i<=NF;i++){
            if(tolower($i)=="map"){ if(i+1<=NF){ print $(i+1); exit } }
          }
        }' <<<"$line")
      if [[ -n "$name" ]]; then
        echo "$name"; return 0
      fi
    done < <(grep -iE '^[[:space:]]*map[[:space:]]+' "$f" 2>/dev/null || true)
  done < <(find "$CONF_DIR" -type f -name "*.conf" -print0 2>/dev/null)
  return 1
}

# Robust vhost finder (safe for set -u):
#  1) exact folder match: $VHOSTS_DIR/<domain>/vhconf.conf
#  2) listener map lines -> vhost name
#  3) search by docRoot == /home/<domain>/public_html (expands $VH_ROOT etc.) across $VHOSTS_DIR + $CONF_DIR
#  4) docRoot contains the domain AND ends with public_html
#  5) path contains the domain
#  6) final heuristic: if exactly 1 non-Example vhost exists, use it
#  7) manual override via 2nd param
vhconf_for(){
  local domain="$1"
  local override="${2:-}"
  if [[ -n "$override" && -f "$override" ]]; then echo "$override"; return; fi

  local candidate="" exact_dr="" hit_sub="" hit_path=""
  exact_dr="$(trim_slash "/home/$domain/public_html")"

  # 1) exact folder match
  candidate="$VHOSTS_DIR/$domain/vhconf.conf"
  if [[ -f "$candidate" ]]; then echo "$candidate"; return; fi

  # 2) listener map -> vhName
  local vhname=""
  if vhname="$(_vhname_from_map "$domain" || true)"; then
    if [[ -n "$vhname" ]]; then
      candidate="$VHOSTS_DIR/$vhname/vhconf.conf"
      if [[ -f "$candidate" ]]; then echo "$candidate"; return; fi
    fi
  fi

  # 3/4/5) scan all vhconfs
  local d="" f="" dr=""
  for d in "$VHOSTS_DIR" "$CONF_DIR"; do
    [[ -d "$d" ]] || continue
    while IFS= read -r -d '' f; do
      dr="$(docroot_from_vhconf "$f" || true)"
      # exact match of expanded docRoot
      if [[ -n "$dr" && "$(trim_slash "$dr")" == "$exact_dr" ]]; then
        echo "$f"; return
      fi
      # loose: expanded docRoot mentions domain + public_html
      if [[ -z "$hit_sub" && -n "$dr" ]]; then
        if echo "$dr" | grep -qiE "/${domain}(/|.*)public_html/?$"; then
          hit_sub="$f"
        fi
      fi
      # path contains domain
      if [[ -z "$hit_path" ]]; then
        if echo "$f" | grep -qi "/${domain}.*vhconf\.conf$"; then
          hit_path="$f"
        fi
      fi
    done < <(find "$d" -type f -name 'vhconf.conf' -print0 2>/dev/null)
  done

  if [[ -n "$hit_sub" ]]; then echo "$hit_sub"; return; fi
  if [[ -n "$hit_path" ]]; then echo "$hit_path"; return; fi

  # 6) heuristic: if there is exactly 1 non-Example vhost, use it
  local one="" count=0
  while IFS= read -r one; do
    [[ "$one" == *"/Example/"* ]] && continue
    count=$((count+1))
  done < <(find "$VHOSTS_DIR" -maxdepth 2 -type f -name 'vhconf.conf' 2>/dev/null)
  if (( count == 1 )); then
    find "$VHOSTS_DIR" -maxdepth 2 -type f -name 'vhconf.conf' | grep -v '/Example/' | head -n1
    return
  fi

  err "OpenLiteSpeed vhost for '$domain' not found under $VHOSTS_DIR or $CONF_DIR.
Hints:
  • Ensure the site exists in CyberPanel.
  • Or pass an explicit file path:  --vhconf /usr/local/lsws/conf/vhosts/<name>/vhconf.conf"
}

workdir_for_domain(){
  local domain="$1"; local vh=""
  vh="$(vhconf_for "$domain" "${2:-}")" || exit 1
  if dr="$(docroot_from_vhconf "$vh")"; then echo "$dr"; return; fi
  if [[ -d "/home/$domain/public_html" ]]; then echo "/home/$domain/public_html"; return; fi
  local guess=""
  guess="$(find /home -maxdepth 3 -type d -path "/home/*/public_html" -printf '%p\n' 2>/dev/null | grep "/$domain/" -m1 || true)"
  [[ -n "$guess" ]] || err "Could not find document root for '$domain'. Ensure the website exists and try again."
  echo "$guess"
}

# ---------- dotnet + port helpers ----------
find_dotnet(){ command -v dotnet >/dev/null 2>&1 && command -v dotnet || return 1; }

get_port_from_service(){
  local svc_path; svc_path="$(service_path "$1")"
  [[ -f "$svc_path" ]] || return 1
  grep -E '^Environment=PORT=' "$svc_path" | sed -E 's/.*PORT=([0-9]+).*/\1/' | tail -n1 || \
  grep -E '^Environment=ASPNETCORE_URLS=' "$svc_path" | sed -E 's/.*:([0-9]+)\s*$/\1/' | tail -n1
}

port_in_use(){ ss -ltnH | awk '{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$1"; }
alloc_port(){
  local domain="$1"
  local seed=$(( ( $(echo -n "$domain" | md5sum | cut -c1-6 | tr 'a-f' '1-6') % 1000 ) + PORT_RANGE_START ))
  local p
  for ((p=seed; p<=PORT_RANGE_END; p++)); do
    if ! port_in_use "$p"; then echo "$p"; return; fi
  done
  err "No free port in $PORT_RANGE_START..$PORT_RANGE_END"
}

resolve_dll_from_marker(){
  local workdir="$1"
  if [[ -f "$workdir/.dotnet" ]]; then
    local dll; dll="$(awk -F= '/^\s*DLL\s*=/{print $2; exit}' "$workdir/.dotnet" | tr -d ' \t\r')"
    [[ -n "$dll" ]] && echo "$dll" && return 0
  fi
  return 1
}

resolve_dll(){
  local workdir="$1"; local dll="${2:-}"
  if [[ -z "$dll" ]]; then
    if dll="$(resolve_dll_from_marker "$workdir")"; then :; else err "--dll <App.dll> is required (or put DLL=YourApp.dll)"; fi
  fi
  if [[ "$dll" = /* && -f "$dll" ]]; then echo "$dll"; return; fi
  if [[ -f "$workdir/$dll" ]]; then echo "$workdir/$dll"; return; fi
  if [[ -d "$workdir" ]]; then
    local found; found="$(find "$workdir" -maxdepth 2 -type f -name "$(basename "$dll")" -print -quit || true)"
    [[ -n "$found" ]] && echo "$found" && return
  fi
  err "DLL '$dll' not found under '$workdir'. Upload your published files to the site's document root."
}

# ---------- OLS integration ----------
ols_reload(){
  if [[ -x "$LSWS_ROOT/bin/lswsctrl" ]]; then "$LSWS_ROOT/bin/lswsctrl" reload || true; fi
  systemctl reload lsws 2>/dev/null || systemctl restart lsws 2>/dev/null || true
}

remove_root_contexts(){
  local vhconf="$1"
  local tmp; tmp="$(mktemp)"
  awk -v B="$MARK_BEGIN" -v E="$MARK_END" '
    BEGIN{del=0; depth=0; inroot=0}
    $0~B{del=1; next}
    $0~E{del=0; next}
    /^[[:space:]]*context[[:space:]]*\/[[:space:]]*\{/ && del==0 {
      inroot=1; depth=1; next
    }
    inroot==1 {
      for(i=1;i<=length($0);i++){
        c=substr($0,i,1)
        if(c=="{")depth++
        else if(c=="}"){depth--; if(depth==0){inroot=0; next}}
      }
      next
    }
    { print }
  ' "$vhconf" > "$tmp"
  mv "$tmp" "$vhconf"
}

inject_proxy_context(){
  local vhconf="$1" port="$2"
  [[ -f "$vhconf" ]] || err "vhconf missing: $vhconf"
  cp -a "$vhconf" "$vhconf.bak.$(date +%s)"

  # 1) Remove any existing root context blocks
  remove_root_contexts "$vhconf"

  # 2) Remove any previous managed block
  local tmp; tmp="$(mktemp)"
  awk -v B="$MARK_BEGIN" -v E="$MARK_END" '
    BEGIN{del=0}
    $0~B{del=1; next}
    $0~E{del=0; next}
    { if(!del) print }
  ' "$vhconf" > "$tmp"
  mv "$tmp" "$vhconf"

  # 3) Append our managed proxy root context
  cat >>"$vhconf" <<EOF
$MARK_BEGIN
context / {
  type                    proxy
  handler                 http://127.0.0.1:$port
  addDefaultCharset       off
  maxConns                256
  rewrite                 0
  cacheEnable             0
}
$MARK_END
EOF
}

remove_proxy_context(){
  local vhconf="$1"
  [[ -f "$vhconf" ]] || return 0
  cp -a "$vhconf" "$vhconf.bak.$(date +%s)"
  awk -v B="$MARK_BEGIN" -v E="$MARK_END" 'BEGIN{del=0} $0~B{del=1; next} $0~E{del=0; next} {if(!del) print $0}' "$vhconf" > "$vhconf.tmp"
  mv "$vhconf.tmp" "$vhconf"
}

# ---------- systemd ----------
create_service(){
  local domain="$1" workdir="$2" port="$3" absdll="$4"
  local svc; svc="$(service_path "$domain")"
  local id; id="$(sanitize_id "$domain")"
  local user; user="$(stat -c '%U' "$workdir" 2>/dev/null || echo "nobody")"
  local envfile; envfile="$(envfile_path "$domain")"

  cat >"$envfile" <<ENV
DOMAIN=$domain
DOCROOT=$workdir
PORT=$port
DLL_PATH=$absdll
ENV

  cat >"$svc" <<UNIT
[Unit]
Description=CyberPanel .NET App for $domain (port $port)
After=network.target

[Service]
Type=simple
User=$user
Group=$user
WorkingDirectory=$workdir
EnvironmentFile=$envfile
ExecStart=/usr/local/bin/cyberpanel-dotnet-wrapper
Restart=always
RestartSec=5
KillSignal=SIGINT
SyslogIdentifier=dotnet-$id

[Install]
WantedBy=multi-user.target
UNIT
}

# ---------- Preflight ----------
autodetect(){
  sudo_ok
  need awk; need sed; need ss; need find; need grep
  local dot; dot="$(find_dotnet)" || err "dotnet runtime not found. Install .NET (e.g., apt install dotnet-runtime-8.0) and retry."
  LSWS_ROOT="$(_detect_lsws_root)" || err "OpenLiteSpeed not found. Install CyberPanel/OpenLiteSpeed first."
  VHOSTS_DIR="$LSWS_ROOT/conf/vhosts"
  CONF_DIR="$LSWS_ROOT/conf"
  [[ -d "$CONF_DIR" ]] || err "OpenLiteSpeed conf directory missing at $CONF_DIR."
  [[ -d "$SYSTEMD_DIR" && -w "$SYSTEMD_DIR" ]] || err "Systemd directory $SYSTEMD_DIR not writable."
}

preflight_domain(){
  local domain="$1" vh_override="${2:-}"
  [[ -n "$domain" ]] || err "Domain is required"
  local vh; vh="$(vhconf_for "$domain" "$vh_override")" || exit 1
  [[ -f "$vh" ]] || err "vhconf not found for $domain"
  local wd; wd="$(workdir_for_domain "$domain" "$vh_override")" || exit 1
  [[ -d "$wd" ]] || err "Document root '$wd' does not exist for $domain"
}

# ---------- Commands ----------
usage(){ cat <<USAGE
cyberpanel-dotnet — manage .NET apps on CyberPanel/OpenLiteSpeed

Commands:
  enable  <domain> [--dll <App.dll>] [--port N] [--vhconf /path/to/vhconf.conf]
  redeploy [<domain>]
  status  <domain>
  logs    <domain> [--lines N|-n N] [-f]
  port    <domain>
  disable <domain> [--vhconf /path/to/vhconf.conf]
  remove  <domain> [--purge-runtime] [--vhconf /path/to/vhconf.conf]
  list
  check   <domain> [--vhconf /path/to/vhconf.conf]
  help
USAGE
}

list_domains(){
  ls -1 $SYSTEMD_DIR/dotnet-app@*.service 2>/dev/null | sed -E 's#.*/dotnet-app@([^/]+)\.service#\1#' | tr '_' '.' | sort || true
}

cmd_check(){
  local domain="$1"; shift || true
  local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --vhconf) vh_override="$2"; shift 2;;
      *) shift;;
    esac
  done
  autodetect; preflight_domain "$domain" "$vh_override"
  local vh; vh="$(vhconf_for "$domain" "$vh_override")"
  local wd; wd="$(workdir_for_domain "$domain" "$vh_override")"
  echo "LSWS_ROOT=$LSWS_ROOT"
  echo "VHOSTS_DIR=$VHOSTS_DIR"
  echo "CONF_DIR=$CONF_DIR"
  echo "VHCONF=$vh"
  echo "DOCROOT=$wd"
  if p="$(get_port_from_service "$domain" 2>/dev/null)"; then echo "PORT=$p"; else echo "PORT=(not assigned yet)"; fi
}

cmd_enable(){
  local domain="$1"; shift || true
  local dll=""; local port=""; local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dll) dll="$2"; shift 2;;
      --port) port="$2"; shift 2;;
      --vhconf) vh_override="$2"; shift 2;;
      *) err "Unknown flag: $1";;
    esac
  done

  autodetect; preflight_domain "$domain" "$vh_override"

  local vh; vh="$(vhconf_for "$domain" "$vh_override")"
  local wd; wd="$(workdir_for_domain "$domain" "$vh_override")"

  # Reuse existing port if service already exists and --port not supplied
  local existing_port=""
  if existing_port="$(get_port_from_service "$domain" 2>/dev/null || true)"; then
    if [[ -z "${port:-}" || ! "$port" =~ ^[0-9]+$ ]]; then
      port="$existing_port"
    fi
  fi
  # If still empty, allocate a new one
  if [[ -z "${port:-}" ]]; then port="$(alloc_port "$domain")"; else [[ "$port" =~ ^[0-9]+$ ]] || err "--port must be a number"; fi

  local dll_path; dll_path="$(resolve_dll "$wd" "$dll")"

  # Write/update service + env; always restart to pick up changes
  create_service "$domain" "$wd" "$port" "$dll_path"
  systemctl daemon-reload
  systemctl enable "$(service_name "$domain")"
  systemctl restart "$(service_name "$domain")"

  # Update reverse proxy to chosen port and reload OLS
  inject_proxy_context "$vh" "$port"
  ols_reload

  local unit; unit="$(service_name "$domain")"
  local envf; envf="$(envfile_path "$domain")"

  grn "✅ Enabled $domain"
  cat <<MSG
------------------------------------------------------------
Public URL:    http(s)://$domain
Reverse proxy: ADDED in $vh (OpenLiteSpeed) [cyberpanel-dotnet markers]
Internal URL:  http://127.0.0.1:$port  (Kestrel)
Systemd unit:  $unit
Env file:      $envf

Next steps:
 • Open your site:   https://$domain   (if SSL is configured in CyberPanel)
 • Live logs:        journalctl -u $unit -f
 • Redeploy now:     sudo cyberpanel-dotnet redeploy $domain
 • Check detected:   sudo cyberpanel-dotnet check $domain
------------------------------------------------------------
MSG
}

cmd_redeploy(){
  autodetect
  local domain="${1:-}"
  if [[ -z "$domain" ]]; then
    local unit=""
    for unit in $SYSTEMD_DIR/dotnet-app@*.service; do
      [[ -f "$unit" ]] || continue
      local name; name="$(basename "$unit" .service)"
      systemctl restart "$name" || true
    done
    grn "Redeployed all managed .NET apps."
  else
    systemctl restart "$(service_name "$domain")"
    grn "Redeployed $domain"
  fi
}

cmd_status(){
  autodetect
  local domain="$1"
  [[ -n "$domain" ]] || err "Domain required"
  systemctl status "$(service_name "$domain")"
}

cmd_logs(){
  autodetect
  local domain="$1"; shift || true
  [[ -n "$domain" ]] || err "Domain required"
  local lines=""; local follow=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--follow) follow="-f"; shift;;
      --lines|-n) lines="-n ${2:-200}"; shift 2;;
      *) shift;;
    esac
  done
  journalctl -u "$(service_name "$domain")" $lines $follow
}

cmd_port(){
  autodetect
  local domain="$1"
  [[ -n "$domain" ]] || err "Domain required"
  if ! p="$(get_port_from_service "$domain")"; then err "No port assigned yet. Run 'enable' first."; fi
  echo "$p"
}

remove_proxy_for(){
  local domain="$1" vh_override="${2:-}"
  local vh; vh="$(vhconf_for "$domain" "$vh_override")"
  remove_proxy_context "$vh" || true
  ols_reload || true
}

cmd_disable(){
  autodetect
  local domain="$1"; shift || true
  local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --vhconf) vh_override="$2"; shift 2;;
      *) shift;;
    esac
  done
  systemctl stop "$(service_name "$domain")" || true
  remove_proxy_for "$domain" "$vh_override"
  grn "Disabled $domain (service stopped, proxy removed)"
}

cmd_remove(){
  autodetect
  local domain="$1"; shift || true
  [[ -n "$domain" ]] || err "Domain required"
  local purge=0; local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --purge-runtime) purge=1; shift;;
      --vhconf) vh_override="$2"; shift 2;;
      *) err "Unknown flag: $1";;
    esac
  done
  systemctl stop "$(service_name "$domain")" || true
  systemctl disable "$(service_name "$domain")" || true
  rm -f "$(service_path "$domain")"
  rm -f "$(envfile_path "$domain")"
  systemctl daemon-reload || true
  remove_proxy_for "$domain" "$vh_override"
  if (( purge == 1 )); then
    local rt="/home/$domain/dotnet"
    [[ -d "$rt" ]] && rm -rf "$rt"
    info "Purged $rt (if existed)."
  fi
  grn "Removed $domain (service + proxy)."
}

# ---------- Entry ----------
main(){
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    enable)      [[ $# -ge 1 ]] || err "Usage: enable <domain> [--dll <App.dll>] [--port N] [--vhconf /path/to/vhconf.conf]"; cmd_enable "$@";;
    redeploy)    cmd_redeploy "$@";;
    status)      [[ # -ge 1 ]] || err "Usage: status <domain>"; cmd_status "$@";;
    logs)        [[ $# -ge 1 ]] || err "Usage: logs <domain> [--lines N|-n N] [-f]"; cmd_logs "$@";;
    port)        [[ $# -ge 1 ]] || err "Usage: port <domain>"; cmd_port "$@";;
    disable)     [[ $# -ge 1 ]] || err "Usage: disable <domain> [--vhconf /path/to/vhconf.conf]"; cmd_disable "$@";;
    remove)      [[ $# -ge 1 ]] || err "Usage: remove <domain> [--purge-runtime] [--vhconf /path/to/vhconf.conf]"; cmd_remove "$@";;
    list)        list_domains;;
    check)       [[ $# -ge 1 ]] || err "Usage: check <domain> [--vhconf /path/to/vhconf.conf]"; cmd_check "$@";;
    help|--help|-h|"") usage;;
    *) err "Unknown command: $cmd";;
  esac
}
main "$@"
