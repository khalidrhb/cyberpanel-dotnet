#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s extglob nullglob

# ===== UI helpers =====
red(){ echo -e "\e[31m$*\e[0m"; }
grn(){ echo -e "\e[32m$*\e[0m"; }
yel(){ echo -e "\e[33m$*\e[0m"; }
err(){ red "[ERROR] $*" 1>&2; exit 1; }
info(){ echo "[i] $*"; }
sudo_ok(){ [[ ${EUID:-$(id -u)} -eq 0 ]] || err "Run as root (sudo)."; }
need(){ command -v "$1" >/dev/null 2>&1 || err "Missing dependency: $1 (please install it)"; }

# ===== Globals =====
SYSTEMD_DIR="/etc/systemd/system"
ENV_DIR="/etc/dotnet-apps"
STATE_DIR="/etc/cyberpanel-dotnet"
PORT_RANGE_START=${PORT_RANGE_START:-5100}
PORT_RANGE_END=${PORT_RANGE_END:-8999}
MARK_BEGIN="# >>> cyberpanel-dotnet BEGIN"
MARK_END="# <<< cyberpanel-dotnet END"

LSWS_ROOT=""
VHOSTS_DIR=""
CONF_DIR=""

mkdir -p "$STATE_DIR" "$ENV_DIR"

# ===== ID helpers =====
sanitize_id(){ echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/_/g; s/[.]/_/g'; }
service_name(){ local id; id=$(sanitize_id "$1"); echo "dotnet-app@${id}.service"; }
service_path(){ echo "$SYSTEMD_DIR/$(service_name "$1")"; }
envfile_path(){ local id; id=$(sanitize_id "$1"); echo "$ENV_DIR/${id}.env"; }

# ===== OpenLiteSpeed discovery =====
_detect_lsws_root(){
  if [[ -n "${LSWS_ROOT:-}" && -x "${LSWS_ROOT}/bin/lswsctrl" ]]; then echo "$LSWS_ROOT"; return; fi
  if [[ -x "/usr/local/lsws/bin/lswsctrl" ]]; then echo "/usr/local/lsws"; return; fi
  if command -v lswsctrl >/dev/null 2>&1; then
    local p; p=$(command -v lswsctrl); p=$(readlink -f "$p" 2>/dev/null || echo "$p")
    echo "${p%/bin/lswsctrl}"; return
  fi
  if [[ -d "/usr/local/lsws" ]]; then echo "/usr/local/lsws"; return; fi
  return 1
}

trim_slash(){ local p="${1:-}"; p="${p%/}"; echo "$p"; }

# Expand $VH_ROOT/$SERVER_ROOT/$VH_NAME inside a vhost conf
_expand_vars(){
  local raw="${1:-}" vhconf="${2:-}"
  local vhroot="" vhname="" serverroot="$LSWS_ROOT"
  vhname="$(basename "$(dirname "$vhconf")")"
  vhroot="$(awk '/^[ \t]*vhRoot[ \t]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  vhroot="${vhroot%\"}"; vhroot="${vhroot#\"}"
  raw="${raw//\$VH_ROOT/$vhroot}"
  raw="${raw//\$SERVER_ROOT/$serverroot}"
  raw="${raw//\$VH_NAME/$vhname}"
  echo "$raw"
}

# Resolve docRoot from a vhconf, expanding variables
docroot_from_vhconf(){
  local vhconf="$1"
  local dr; dr="$(awk '/^[ \t]*docRoot[ \t]+/{print $2; exit}' "$vhconf" 2>/dev/null || true)"
  dr="${dr%\"}"; dr="${dr#\"}"
  [[ -z "$dr" ]] && return 1
  dr="$(_expand_vars "$dr" "$vhconf")"
  dr="${dr%\"}"; dr="${dr#\"}"
  dr="$(trim_slash "$dr")"
  [[ -n "$dr" ]] && echo "$dr" && return 0
  return 1
}

# Parse listener "map" lines anywhere in $CONF_DIR to resolve domain -> vhost name
_vhname_from_map(){
  local domain="$1"
  local f line name
  while IFS= read -r -d '' f; do
    while IFS= read -r line; do
      echo "$line" | grep -qi -- "$domain" || continue
      name=$(awk '
        BEGIN{IGNORECASE=1}
        /^[ \t]*map[ \t]+/ {
          for(i=1;i<=NF;i++){
            if(tolower($i)=="map"){ if(i+1<=NF){ print $(i+1); exit } }
          }
        }' <<<"$line")
      if [[ -n "$name" ]]; then echo "$name"; return 0; fi
    done < <(grep -iE '^[ \t]*map[ \t]+' "$f" 2>/dev/null || true)
  done < <(find "$CONF_DIR" -type f -name "*.conf" -print0 2>/dev/null)
  return 1
}

# Robust vhost finder
vhconf_for(){
  local domain="$1"
  local override="${2:-}"
  if [[ -n "$override" && -f "$override" ]]; then echo "$override"; return; fi

  local candidate="" exact_dr="" hit_sub="" hit_path=""
  exact_dr="$(trim_slash "/home/$domain/public_html")"

  candidate="$VHOSTS_DIR/$domain/vhconf.conf"
  if [[ -f "$candidate" ]]; then echo "$candidate"; return; fi

  local vhname=""
  if vhname="$(_vhname_from_map "$domain" || true)"; then
    if [[ -n "$vhname" ]]; then
      candidate="$VHOSTS_DIR/$vhname/vhconf.conf"
      [[ -f "$candidate" ]] && { echo "$candidate"; return; }
    fi
  fi

  local d f dr
  for d in "$VHOSTS_DIR" "$CONF_DIR"; do
    [[ -d "$d" ]] || continue
    while IFS= read -r -d '' f; do
      dr="$(docroot_from_vhconf "$f" || true)"
      if [[ -n "$dr" && "$(trim_slash "$dr")" == "$exact_dr" ]]; then echo "$f"; return; fi
      if [[ -z "$hit_sub" && -n "$dr" ]]; then
        echo "$dr" | grep -qiE "/${domain}(/|.*)public_html/?$" && hit_sub="$f"
      fi
      if [[ -z "$hit_path" ]]; then
        echo "$f" | grep -qi "/${domain}.*vhconf\.conf$" && hit_path="$f"
      fi
    done < <(find "$d" -type f -name 'vhconf.conf' -print0 2>/dev/null)
  done

  [[ -n "$hit_sub" ]]  && { echo "$hit_sub"; return; }
  [[ -n "$hit_path" ]] && { echo "$hit_path"; return; }

  local cnt=0 last=""
  for f in "$VHOSTS_DIR"/*/vhconf.conf; do
    [[ "$f" == *"/Example/vhconf.conf" ]] && continue
    cnt=$((cnt+1)); last="$f"
  done
  (( cnt == 1 )) && { echo "$last"; return; }

  err "OpenLiteSpeed vhost for '$domain' not found under $VHOSTS_DIR or $CONF_DIR.
Hints:
  • Ensure the site exists in CyberPanel.
  • Or pass an explicit file path:  --vhconf /usr/local/lsws/conf/vhosts/<name>/vhconf.conf"
}

workdir_for_domain(){
  local domain="$1"; local vh=""
  vh="$(vhconf_for "$domain" "${2:-}")" || exit 1
  if dr="$(docroot_from_vhconf "$vh")"; then echo "$dr"; return; fi
  [[ -d "/home/$domain/public_html" ]] && { echo "/home/$domain/public_html"; return; }
  local guess=""
  guess="$(find /home -maxdepth 3 -type d -path "/home/*/public_html" -printf '%p\n' 2>/dev/null | grep "/$domain/" -m1 || true)"
  [[ -n "$guess" ]] || err "Could not find document root for '$domain'. Ensure the website exists and try again."
  echo "$guess"
}

# ===== dotnet + port helpers =====
find_dotnet(){ command -v dotnet >/dev/null 2>&1 && command -v dotnet || return 1; }

get_port_from_service(){
  local domain="$1"
  local envf; envf="$(envfile_path "$domain")"
  if [[ -f "$envf" ]]; then
    local p; p="$(awk -F= '/^PORT=/{print $2; exit}' "$envf" | tr -d ' \t\r')"
    [[ -n "$p" ]] && { echo "$p"; return; }
  fi
  local svc_path; svc_path="$(service_path "$domain")"
  if [[ -f "$svc_path" ]]; then
    local p
    p="$(sed -n 's/^Environment=PORT=\([0-9]\+\).*$/\1/p' "$svc_path" | tail -n1)"; [[ -n "$p" ]] && { echo "$p"; return; }
    p="$(sed -n 's/^Environment=ASPNETCORE_URLS=.*:\([0-9]\+\).*$/\1/p' "$svc_path" | tail -n1)"; [[ -n "$p" ]] && { echo "$p"; return; }
  fi
  local p; p="$(systemctl show "$(service_name "$domain")" -p Environment 2>/dev/null | sed -n 's/^Environment=.*PORT=\([0-9]\+\).*$/\1/p' | head -n1)"
  [[ -n "$p" ]] && echo "$p" || return 1
}

port_in_use(){ ss -ltnH | awk '{print $4}' | sed -E 's/.*:([0-9]+)$/\1/' | grep -qx "$1"; }

alloc_port(){
  local domain="$1"
  local seed=$(( ( $(echo -n "$domain" | md5sum | cut -c1-6 | tr 'a-f' '1-6') % 1000 ) + PORT_RANGE_START ))
  local p
  for ((p=seed; p<=PORT_RANGE_END; p++)); do
    if ! port_in_use "$p"; then echo "$p"; return; fi
  done
  err "No free port in $PORT_RANGE_START..$PORT_RANGE_END"
}

resolve_dll_from_marker(){
  local workdir="$1"
  if [[ -f "$workdir/.dotnet" ]]; then
    local dll; dll="$(awk -F= '/^\s*DLL\s*=/{print $2; exit}' "$workdir/.dotnet" | tr -d ' \t\r')"
    [[ -n "$dll" ]] && { echo "$dll"; return; }
  fi
  return 1
}

resolve_dll(){
  local workdir="$1"; local dll="${2:-}"
  if [[ -z "$dll" ]]; then
    if dll="$(resolve_dll_from_marker "$workdir")"; then :; else err "--dll <App.dll> is required (or put DLL=YourApp.dll in .dotnet)"; fi
  fi
  if [[ "$dll" = /* && -f "$dll" ]]; then echo "$dll"; return; fi
  if [[ -f "$workdir/$dll" ]]; then echo "$workdir/$dll"; return; fi
  if [[ -d "$workdir" ]]; then
    local found; found="$(find "$workdir" -maxdepth 2 -type f -name "$(basename "$dll")" -print -quit || true)"
    [[ -n "$found" ]] && { echo "$found"; return; }
  fi
  err "DLL '$dll' not found under '$workdir'. Upload your published files to the site's document root."
}

# ===== OLS integration =====
ols_reload(){
  if [[ -x "$LSWS_ROOT/bin/lswsctrl" ]]; then "$LSWS_ROOT/bin/lswsctrl" reload || true; fi
  systemctl reload lsws 2>/dev/null || systemctl restart lsws 2>/dev/null || true
}

# Remove ALL existing root "context / { ... }" blocks (regardless of source)
remove_root_contexts(){
  local vhconf="$1"
  local tmp; tmp="$(mktemp)"
  awk '
    BEGIN{depth=0; inroot=0}
    /^[ \t]*context[ \t]*\/[ \t]*\{/ { inroot=1; depth=1; next }
    inroot==1 {
      for(i=1;i<=length($0);i++){
        c=substr($0,i,1)
        if(c=="{")depth++
        else if(c=="}"){ depth--; if(depth==0){ inroot=0; next } }
      }
      next
    }
    { print }
  ' "$vhconf" > "$tmp"
  mv "$tmp" "$vhconf"
}

inject_proxy_context(){
  local vhconf="$1" port="$2"
  [[ -f "$vhconf" ]] || err "vhconf missing: $vhconf"
  cp -a "$vhconf" "$vhconf.bak.$(date +%s)"
  remove_root_contexts "$vhconf"
  sed -i '/^# >>> cyberpanel-dotnet BEGIN/,/^# <<< cyberpanel-dotnet END/d' "$vhconf"
  cat >>"$vhconf" <<EOF
$MARK_BEGIN
context / {
  type                    proxy
  handler                 http://127.0.0.1:$port
  addDefaultCharset       off
  maxConns                256
  rewrite                 0
  cacheEnable             0
}
$MARK_END
EOF
}

# Ensure vhDomain contains domain + www.domain in the vhost conf
ensure_vh_domain(){
  local domain="$1" vhconf="$2"
  local d1="$domain" d2="www.$domain"
  if grep -qiE '^[[:space:]]*vhDomain[[:space:]]+' "$vhconf"; then
    # merge if missing
    local line; line="$(grep -iE '^[[:space:]]*vhDomain[[:space:]]+' "$vhconf" | head -n1)"
    local rest="${line#*vhDomain}"; rest="$(echo "$rest" | tr -d '\r')"
    # normalize commas/spaces
    rest="$(echo "$rest" | tr ',' ' ' | xargs -n1 echo | tr '[:upper:]' '[:lower:]' | sed '/^$/d' | sort -u | tr '\n' ' ')"
    echo "$rest" | grep -qw "$d1" || rest="$rest $d1"
    echo "$rest" | grep -qw "$d2" || rest="$rest $d2"
    rest="$(echo "$rest" | xargs | tr ' ' ',')"
    sed -i "0,/^[[:space:]]*vhDomain[[:space:]]\+.*$/s//vhDomain $rest/" "$vhconf"
  else
    printf '\n# added by cyberpanel-dotnet\nvhDomain %s, %s\n' "$d1" "$d2" >> "$vhconf"
  fi
}

# Ensure mapping in listeners for domain + www.domain (portable awk)
fix_listener_mappings(){
  local domain="$1" vhconf="$2"
  local httpdc="$CONF_DIR/httpd_config.conf"
  [[ -f "$httpdc" ]] || err "OpenLiteSpeed httpd_config.conf not found at $httpdc"

  local vhname; vhname="$(basename "$(dirname "$vhconf")")"
  local d1="$domain"
  local d2="www.$domain"

  cp -a "$httpdc" "$httpdc.bak.$(date +%s)"

  awk -v VH="$vhname" -v D1="$d1" -v D2="$d2" '
    BEGIN { blk=0; addr=""; sec="0"; hasmap=0 }
    {
      line=$0
      if (line ~ /^[ \t]*listener[ \t]+/) { blk=1; addr=""; sec="0"; hasmap=0; print line; next }
      if (blk==1) {
        if (line ~ /^[ \t]*address[ \t]+/) { tmp=line; gsub(/^[ \t]*address[ \t]+/, "", tmp); split(tmp,a,/[ \t]/); addr=a[1]; print $0; next }
        if (line ~ /^[ \t]*secure[ \t]+/)  { tmp=line; gsub(/^[ \t]*secure[ \t]+/,  "", tmp); split(tmp,a,/[ \t]/); sec=a[1];  print $0; next }
        if (line ~ /^[ \t]*map[ \t]+/) {
          if (index(line, D1)>0 || index(line, D2)>0) {
            hasmap=1    # drop old dup by skipping this line
            next
          }
          print $0
          next
        }
        if (line ~ /^[ \t]*}/) {
          need=0
          if (addr ~ /:80/  || addr ~ /\*:80/  || addr ~ /0\.0\.0\.0:80/  || addr ~ /\[::\]:80/)  need=1
          if (sec=="1"     || addr ~ /:443/   || addr ~ /\*:443/         || addr ~ /0\.0\.0\.0:443/ || addr ~ /\[::\]:443/) need=1
          if (need==1) {
            print "  map  " VH "  " D1 " " D2
          }
          blk=0; addr=""; sec="0"; hasmap=0
          print $0
          next
        }
      }
      print $0
    }
  ' "$httpdc" > /tmp/httpd_config.conf.new

  mv /tmp/httpd_config.conf.new "$httpdc"
  ols_reload

  echo "--- Listener mappings for $domain ---"
  awk -v D1="$d1" -v D2="$d2" '
    BEGIN{L="";A="";S="0"}
    /^[ \t]*listener[ \t]+/ {L=$2; A=""; S="0"}
    /^[ \t]*address[ \t]+/  {line=$0; sub(/^[ \t]*address[ \t]+/, "", line); split(line,a,/[ \t]/); A=a[1]}
    /^[ \t]*secure[ \t]+/   {line=$0; sub(/^[ \t]*secure[ \t]+/,  "", line); split(line,a,/[ \t]/); S=a[1]}
    /^[ \t]*map[ \t]+/ {
      if (index($0,D1)>0 || index($0,D2)>0) {
        printf("listener=%s  address=%s  secure=%s  %s\n", L, A, S, $0)
      }
    }
  ' "$httpdc" || true
}

# ===== systemd =====
create_service(){
  local domain="$1" workdir="$2" port="$3" absdll="$4"
  local svc; svc="$(service_path "$domain")"
  local id; id="$(sanitize_id "$domain")"
  local user; user="$(stat -c '%U' "$workdir" 2>/dev/null || echo "nobody")"
  local envfile; envfile="$(envfile_path "$domain")"

  cat >"$envfile" <<ENV
DOMAIN=$domain
DOCROOT=$workdir
PORT=$port
DLL_PATH=$absdll
ENV

  cat >"$svc" <<UNIT
[Unit]
Description=CyberPanel .NET App for $domain (port $port)
After=network.target

[Service]
Type=simple
User=$user
Group=$user
WorkingDirectory=$workdir
EnvironmentFile=$envfile
ExecStart=/usr/local/bin/cyberpanel-dotnet-wrapper
Restart=always
RestartSec=5
KillSignal=SIGINT
SyslogIdentifier=dotnet-$id

[Install]
WantedBy=multi-user.target
UNIT
}

# ===== Preflight =====
autodetect(){
  sudo_ok
  need awk; need sed; need ss; need find; need grep
  local dot; dot="$(find_dotnet)" || err "dotnet runtime not found. Install .NET (e.g., apt install dotnet-runtime-8.0) and retry."
  LSWS_ROOT="$(_detect_lsws_root)" || err "OpenLiteSpeed not found. Install CyberPanel/OpenLiteSpeed first."
  VHOSTS_DIR="$LSWS_ROOT/conf/vhosts"
  CONF_DIR="$LSWS_ROOT/conf"
  [[ -d "$CONF_DIR" ]] || err "OpenLiteSpeed conf directory missing at $CONF_DIR."
  [[ -d "$SYSTEMD_DIR" && -w "$SYSTEMD_DIR" ]] || err "Systemd directory $SYSTEMD_DIR not writable."
}

preflight_domain(){
  local domain="$1" vh_override="${2:-}"
  [[ -n "$domain" ]] || err "Domain is required"
  local vh; vh="$(vhconf_for "$domain" "$vh_override")" || exit 1
  [[ -f "$vh" ]] || err "vhconf not found for $domain"
  local wd; wd="$(workdir_for_domain "$domain" "$vh_override")" || exit 1
  [[ -d "$wd" ]] || err "Document root '$wd' does not exist for $domain"
}

# ===== Commands =====
usage(){ cat <<'USAGE'
cyberpanel-dotnet — manage .NET apps on CyberPanel/OpenLiteSpeed

Commands:
  enable   <domain> [--dll <App.dll>] [--port N] [--vhconf /path/to/vhconf.conf]
  redeploy [<domain>]
  status   <domain>
  logs     <domain> [--lines N|-n N] [-f]
  port     <domain>
  disable  <domain> [--vhconf /path/to/vhconf.conf]
  remove   <domain> [--purge-runtime] [--vhconf /path/to/vhconf.conf]
  list
  check    <domain> [--vhconf /path/to/vhconf.conf]
  fixmap   <domain> [--vhconf /path/to/vhconf.conf]
  help
USAGE
}

list_domains(){
  local f
  for f in "$SYSTEMD_DIR"/dotnet-app@*.service; do
    basename "$f" | sed -E 's/dotnet-app@([^/]+)\.service/\1/' | tr '_' '.'
  done | sort || true
}

cmd_check(){
  local domain="$1"; shift || true
  local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --vhconf) vh_override="$2"; shift 2;;
      *) shift;;
    esac
  done
  autodetect; preflight_domain "$domain" "$vh_override"
  local vh; vh="$(vhconf_for "$domain" "$vh_override")"
  local wd; wd="$(workdir_for_domain "$domain" "$vh_override")"
  echo "LSWS_ROOT=$LSWS_ROOT"
  echo "VHOSTS_DIR=$VHOSTS_DIR"
  echo "CONF_DIR=$CONF_DIR"
  echo "VHCONF=$vh"
  echo "DOCROOT=$wd"
  local p_env=""
  if p_env="$(get_port_from_service "$domain" 2>/dev/null)"; then echo "PORT=$p_env"; else echo "PORT=(not assigned yet)"; fi
  local p_proxy=""
  p_proxy="$(awk '/^[ \t]*handler[ \t]+http:\/\/127\.0\.0\.1:/ { if (match($0, /127\.0\.0\.1:([0-9]+)/, a)) { print a[1]; exit } }' "$vh" 2>/dev/null || true)"
  [[ -n "$p_proxy" ]] && echo "PROXY_PORT=$p_proxy"
}

cmd_enable(){
  local domain="$1"; shift || true
  local dll=""; local port=""; local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dll) dll="$2"; shift 2;;
      --port) port="$2"; shift 2;;
      --vhconf) vh_override="$2"; shift 2;;
      *) err "Unknown flag: $1";;
    esac
  done

  autodetect; preflight_domain "$domain" "$vh_override"
  local vh; vh="$(vhconf_for "$domain" "$vh_override")"
  local wd; wd="$(workdir_for_domain "$domain" "$vh_override")"

  local existing_port=""
  if existing_port="$(get_port_from_service "$domain" 2>/dev/null || true)"; then
    if [[ -z "${port:-}" || ! "$port" =~ ^[0-9]+$ ]]; then port="$existing_port"; fi
  fi
  if [[ -z "${port:-}" ]]; then port="$(alloc_port "$domain")"; else [[ "$port" =~ ^[0-9]+$ ]] || err "--port must be a number"; fi

  local dll_path; dll_path="$(resolve_dll "$wd" "$dll")"

  local dpdir="/home/$domain/.aspnet/DataProtection-Keys"
  mkdir -p "$dpdir" || true
  chown -R "$(stat -c '%U' "$wd")":"$(stat -c '%U' "$wd")" "/home/$domain/.aspnet" || true

  create_service "$domain" "$wd" "$port" "$dll_path"
  if ! grep -q '^ASPNETCORE_DATA_PROTECTION_DIR=' "$(envfile_path "$domain")"; then
    echo "ASPNETCORE_DATA_PROTECTION_DIR=$dpdir" >> "$(envfile_path "$domain")"
  fi

  systemctl daemon-reload
  systemctl enable "$(service_name "$domain")"
  systemctl restart "$(service_name "$domain")"

  # vhost side: de-dup contexts and inject proxy
  inject_proxy_context "$vh" "$port"
  # ensure vhost declares domains
  ensure_vh_domain "$domain" "$vh"
  ols_reload

  # server side: ensure listener mappings (HTTP+HTTPS)
  fix_listener_mappings "$domain" "$vh"

  local unit; unit="$(service_name "$domain")"
  local envf; envf="$(envfile_path "$domain")"

  grn "✅ Enabled $domain"
  cat <<MSG
------------------------------------------------------------
Public URL:    http(s)://$domain
Reverse proxy: ADDED in $vh (OpenLiteSpeed) [cyberpanel-dotnet markers]
Internal URL:  http://127.0.0.1:$port  (Kestrel)
Systemd unit:  $unit
Env file:      $envf

Next steps:
 • Open your site:   https://$domain   (if SSL is configured in CyberPanel)
 • Live logs:        journalctl -u $unit -f
 • Redeploy now:     sudo cyberpanel-dotnet redeploy $domain
 • Check detected:   sudo cyberpanel-dotnet check $domain
------------------------------------------------------------
MSG
}

cmd_redeploy(){
  autodetect
  local domain="${1:-}"
  if [[ -z "$domain" ]]; then
    local unit name
    for unit in "$SYSTEMD_DIR"/dotnet-app@*.service; do
      [[ -f "$unit" ]] || continue
      name="$(basename "$unit" .service)"
      systemctl restart "$name" || true
    done
    grn "Redeployed all managed .NET apps."
  else
    systemctl restart "$(service_name "$domain")"
    grn "Redeployed $domain"
  fi
}

cmd_status(){
  autodetect
  local domain="$1"
  [[ -n "$domain" ]] || err "Domain required"
  systemctl status "$(service_name "$domain")"
}

cmd_logs(){
  autodetect
  local domain="$1"; shift || true
  [[ -n "$domain" ]] || err "Domain required"
  local lines="-n 200"; local follow=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--follow) follow="-f"; shift;;
      --lines|-n) lines="-n ${2:-200}"; shift 2;;
      *) shift;;
    esac
  done
  journalctl -u "$(service_name "$domain")" $lines $follow
}

cmd_port(){
  autodetect
  local domain="$1"
  [[ -n "$domain" ]] || err "Domain required"
  if ! p="$(get_port_from_service "$domain")"; then err "No port assigned yet. Run 'enable' first."; fi
  echo "$p"
}

remove_proxy_for(){
  local domain="$1" vh_override="${2:-}"
  local vh; vh="$(vhconf_for "$domain" "$vh_override")"
  remove_proxy_context "$vh" || true
  ols_reload || true
}

cmd_disable(){
  autodetect
  local domain="$1"; shift || true
  local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --vhconf) vh_override="$2"; shift 2;;
      *) shift;;
    esac
  done
  systemctl stop "$(service_name "$domain")" || true
  remove_proxy_for "$domain" "$vh_override"
  grn "Disabled $domain (service stopped, proxy removed)"
}

cmd_remove(){
  autodetect
  local domain="$1"; shift || true
  [[ -n "$domain" ]] || err "Domain required"
  local purge=0; local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --purge-runtime) purge=1; shift;;
      --vhconf) vh_override="$2"; shift 2;;
      *) err "Unknown flag: $1";;
    esac
  done
  systemctl stop "$(service_name "$domain")" || true
  systemctl disable "$(service_name "$domain")" || true
  rm -f "$(service_path "$domain")"
  rm -f "$(envfile_path "$domain")"
  systemctl daemon-reload || true
  remove_proxy_for "$domain" "$vh_override"
  if (( purge == 1 )); then
    local rt="/home/$domain/dotnet"
    [[ -d "$rt" ]] && rm -rf "$rt"
    info "Purged $rt (if existed)."
  fi
  grn "Removed $domain (service + proxy)."
}

cmd_fixmap(){
  local domain="$1"; shift || true
  local vh_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --vhconf) vh_override="$2"; shift 2;;
      *) shift;;
    esac
  done
  autodetect; preflight_domain "$domain" "$vh_override"
  local vh; vh="$(vhconf_for "$domain" "$vh_override")"
  ensure_vh_domain "$domain" "$vh"
  fix_listener_mappings "$domain" "$vh"
  grn "Mappings ensured for $domain → $(basename "$(dirname "$vh")")."
  echo "Tip: test via  curl -k -I https://$domain  and  curl -I http://$domain"
}

# ===== Entry =====
main(){
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    enable)    [[ $# -ge 1 ]] || err "Usage: enable <domain> [--dll <App.dll>] [--port N] [--vhconf /path/to/vhconf.conf]"; cmd_enable "$@";;
    redeploy)  cmd_redeploy "$@";;
    status)    [[ $# -ge 1 ]] || err "Usage: status <domain>"; cmd_status "$@";;
    logs)      [[ $# -ge 1 ]] || err "Usage: logs <domain> [--lines N|-n N] [-f]"; cmd_logs "$@";;
    port)      [[ $# -ge 1 ]] || err "Usage: port <domain>"; cmd_port "$@";;
    disable)   [[ $# -ge 1 ]] || err "Usage: disable <domain> [--vhconf /path/to/vhconf.conf]"; cmd_disable "$@";;
    remove)    [[ $# -ge 1 ]] || err "Usage: remove <domain> [--purge-runtime] [--vhconf /path/to/vhconf.conf]"; cmd_remove "$@";;
    list)      list_domains;;
    check)     [[ $# -ge 1 ]] || err "Usage: check <domain> [--vhconf /path/to/vhconf.conf]"; cmd_check "$@";;
    fixmap)    [[ $# -ge 1 ]] || err "Usage: fixmap <domain> [--vhconf /path/to/vhconf.conf]"; cmd_fixmap "$@";;
    help|--help|-h|"") usage;;
    *) err "Unknown command: $cmd";;
  esac
}
main "$@"
